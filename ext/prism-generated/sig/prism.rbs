# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/sig/prism.rbs.erb
# if you are looking to modify the template

module Prism
  # Represents the use of the `alias` keyword to alias a global variable.
  #
  #     alias $foo $bar
  #     ^^^^^^^^^^^^^^^
  class AliasGlobalVariableNode < Node
    attr_reader new_name: Node
    attr_reader old_name: Node
    attr_reader keyword_loc: Location

    def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AliasGlobalVariableNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `alias` keyword to alias a method.
  #
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasMethodNode < Node
    attr_reader new_name: Node
    attr_reader old_name: Node
    attr_reader keyword_loc: Location

    def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AliasMethodNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an alternation pattern in pattern matching.
  #
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    attr_reader left: Node
    attr_reader right: Node
    attr_reader operator_loc: Location

    def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AlternationPatternNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&` operator or the `and` keyword.
  #
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    attr_reader left: Node
    attr_reader right: Node
    attr_reader operator_loc: Location

    def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AndNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a set of arguments to a method or a keyword.
  #
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    attr_reader arguments: Array[Node]
    attr_reader flags: Integer

    def initialize: (arguments: Array[Node], flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ArgumentsNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword_splat?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an array literal. This can be a regular array using brackets or
  # a special array using % like %w or %i.
  #
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    attr_reader elements: Array[Node]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ArrayNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an array pattern in pattern matching.
  #
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  #
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  #
  #     foo in *1
  #     ^^^^^^^^^
  #
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  #
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    attr_reader constant: Node?
    attr_reader requireds: Array[Node]
    attr_reader rest: Node?
    attr_reader posts: Array[Node]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ArrayPatternNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a hash key/value pair.
  #
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    attr_reader key: Node
    attr_reader value: Node?
    attr_reader operator_loc: Location?

    def initialize: (key: Node, value: Node?, operator_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AssocNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a splat in a hash literal.
  #
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    attr_reader value: Node?
    attr_reader operator_loc: Location

    def initialize: (value: Node?, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> AssocSplatNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents reading a reference to a field in the previous match.
  #
  #     $'
  #     ^^
  class BackReferenceReadNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BackReferenceReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a begin statement.
  #
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    attr_reader begin_keyword_loc: Location?
    attr_reader statements: StatementsNode?
    attr_reader rescue_clause: RescueNode?
    attr_reader else_clause: ElseNode?
    attr_reader ensure_clause: EnsureNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BeginNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def begin_keyword: () -> String?

    def end_keyword: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents block method arguments.
  #
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    attr_reader expression: Node?
    attr_reader operator_loc: Location

    def initialize: (expression: Node?, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BlockArgumentNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a block local variable.
  #
  #     a { |; b| }
  #            ^
  class BlockLocalVariableNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BlockLocalVariableNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a block of ruby code.
  #
  # [1, 2, 3].each { |i| puts x }
  #                ^^^^^^^^^^^^^^
  class BlockNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader parameters: BlockParametersNode?
    attr_reader body: Node?
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (locals: Array[Symbol], parameters: BlockParametersNode?, body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BlockNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a block parameter to a method, block, or lambda definition.
  #
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BlockParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a block's parameters declaration.
  #
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    attr_reader parameters: ParametersNode?
    attr_reader locals: Array[Node]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (parameters: ParametersNode?, locals: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BlockParametersNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `break` keyword.
  #
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    attr_reader arguments: ArgumentsNode?
    attr_reader keyword_loc: Location

    def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> BreakNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator on a call.
  #
  #     foo.bar &&= value
  #     ^^^^^^^^^^^^^^^^^
  class CallAndWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader flags: Integer
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CallAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def message: () -> String?

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a method call, in all of the various forms that can take.
  #
  #     foo
  #     ^^^
  #
  #     foo()
  #     ^^^^^
  #
  #     +foo
  #     ^^^^
  #
  #     foo + bar
  #     ^^^^^^^^^
  #
  #     foo.bar
  #     ^^^^^^^
  #
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader opening_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location?
    attr_reader block: Node?
    attr_reader flags: Integer
    attr_reader name: Symbol

    def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Node?, flags: Integer, name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CallNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def message: () -> String?

    def opening: () -> String?

    def closing: () -> String?

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of an assignment operator on a call.
  #
  #     foo.bar += baz
  #     ^^^^^^^^^^^^^^
  class CallOperatorWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader flags: Integer
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader operator: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CallOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def message: () -> String?

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator on a call.
  #
  #     foo.bar ||= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOrWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader flags: Integer
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CallOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def message: () -> String?

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a local variable in pattern matching.
  #
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    attr_reader value: Node
    attr_reader target: Node
    attr_reader operator_loc: Location

    def initialize: (value: Node, target: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CapturePatternNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of a case statement.
  #
  #     case true
  #     when false
  #     end
  #     ^^^^^^^^^^
  class CaseNode < Node
    attr_reader predicate: Node?
    attr_reader conditions: Array[Node]
    attr_reader consequent: ElseNode?
    attr_reader case_keyword_loc: Location
    attr_reader end_keyword_loc: Location

    def initialize: (predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> CaseNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def case_keyword: () -> String

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a class declaration involving the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader class_keyword_loc: Location
    attr_reader constant_path: Node
    attr_reader inheritance_operator_loc: Location?
    attr_reader superclass: Node?
    attr_reader body: Node?
    attr_reader end_keyword_loc: Location
    attr_reader name: Symbol

    def initialize: (locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def class_keyword: () -> String

    def inheritance_operator: () -> String?

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to a class variable.
  #
  #     @@target &&= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableAndWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a class variable using an operator that isn't `=`.
  #
  #     @@target += value
  #     ^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader operator: Symbol

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to a class variable.
  #
  #     @@target ||= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableOrWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents referencing a class variable.
  #
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a class variable in a context that doesn't have an explicit value.
  #
  #     @@foo, @@bar = baz
  #     ^^^^^  ^^^^^
  class ClassVariableTargetNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a class variable.
  #
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Node
    attr_reader operator_loc: Location?

    def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ClassVariableWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to a constant.
  #
  #     Target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantAndWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a constant using an operator that isn't `=`.
  #
  #     Target += value
  #     ^^^^^^^^^^^^^^^
  class ConstantOperatorWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader operator: Symbol

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to a constant.
  #
  #     Target ||= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOrWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to a constant path.
  #
  #     Parent::Child &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathAndWriteNode < Node
    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents accessing a constant through a path of `::` operators.
  #
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    attr_reader parent: Node?
    attr_reader child: Node
    attr_reader delimiter_loc: Location

    def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def delimiter: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a constant path using an operator that isn't `=`.
  #
  #     Parent::Child += value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorWriteNode < Node
    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader operator: Symbol

    def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to a constant path.
  #
  #     Parent::Child ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOrWriteNode < Node
    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a constant path in a context that doesn't have an explicit value.
  #
  #     Foo::Foo, Bar::Bar = baz
  #     ^^^^^^^^  ^^^^^^^^
  class ConstantPathTargetNode < Node
    attr_reader parent: Node?
    attr_reader child: Node
    attr_reader delimiter_loc: Location

    def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def delimiter: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a constant path.
  #
  #     ::Foo = 1
  #     ^^^^^^^^^
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  #
  #     ::Foo::Bar = 1
  #     ^^^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantPathWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents referencing a constant.
  #
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a constant in a context that doesn't have an explicit value.
  #
  #     Foo, Bar = baz
  #     ^^^  ^^^
  class ConstantTargetNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a constant.
  #
  #     Foo = 1
  #     ^^^^^^^
  class ConstantWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Node
    attr_reader operator_loc: Location

    def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ConstantWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a method definition.
  #
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader receiver: Node?
    attr_reader parameters: ParametersNode?
    attr_reader body: Node?
    attr_reader locals: Array[Symbol]
    attr_reader def_keyword_loc: Location
    attr_reader operator_loc: Location?
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?
    attr_reader equal_loc: Location?
    attr_reader end_keyword_loc: Location?

    def initialize: (name: Symbol, name_loc: Location, receiver: Node?, parameters: ParametersNode?, body: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> DefNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def def_keyword: () -> String

    def operator: () -> String?

    def lparen: () -> String?

    def rparen: () -> String?

    def equal: () -> String?

    def end_keyword: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `defined?` keyword.
  #
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    attr_reader lparen_loc: Location?
    attr_reader value: Node
    attr_reader rparen_loc: Location?
    attr_reader keyword_loc: Location

    def initialize: (lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> DefinedNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def lparen: () -> String?

    def rparen: () -> String?

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  #
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    attr_reader else_keyword_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ElseNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def else_keyword: () -> String

    def end_keyword: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an interpolated set of statements.
  #
  #     "foo #{bar}"
  #          ^^^^^^
  class EmbeddedStatementsNode < Node
    attr_reader opening_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader closing_loc: Location

    def initialize: (opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> EmbeddedStatementsNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an interpolated variable.
  #
  #     "foo #@bar"
  #          ^^^^^
  class EmbeddedVariableNode < Node
    attr_reader operator_loc: Location
    attr_reader variable: Node

    def initialize: (operator_loc: Location, variable: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> EmbeddedVariableNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an `ensure` clause in a `begin` statement.
  #
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    attr_reader ensure_keyword_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader end_keyword_loc: Location

    def initialize: (ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> EnsureNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def ensure_keyword: () -> String

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the literal `false` keyword.
  #
  #     false
  #     ^^^^^
  class FalseNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> FalseNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a find pattern in pattern matching.
  #
  #     foo in *bar, baz, *qux
  #            ^^^^^^^^^^^^^^^
  #
  #     foo in [*bar, baz, *qux]
  #            ^^^^^^^^^^^^^^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #            ^^^^^^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    attr_reader constant: Node?
    attr_reader left: Node
    attr_reader requireds: Array[Node]
    attr_reader right: Node
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> FindPatternNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `..` or `...` operators to create flip flops.
  #
  #     baz if foo .. bar
  #            ^^^^^^^^^^
  class FlipFlopNode < Node
    attr_reader left: Node?
    attr_reader right: Node?
    attr_reader operator_loc: Location
    attr_reader flags: Integer

    def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> FlipFlopNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def exclude_end?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a floating point number literal.
  #
  #     1.0
  #     ^^^
  class FloatNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> FloatNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `for` keyword.
  #
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    attr_reader index: Node
    attr_reader collection: Node
    attr_reader statements: StatementsNode?
    attr_reader for_keyword_loc: Location
    attr_reader in_keyword_loc: Location
    attr_reader do_keyword_loc: Location?
    attr_reader end_keyword_loc: Location

    def initialize: (index: Node, collection: Node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ForNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def for_keyword: () -> String

    def in_keyword: () -> String

    def do_keyword: () -> String?

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents forwarding all arguments to this method to another method.
  #
  #     def foo(...)
  #       bar(...)
  #           ^^^
  #     end
  class ForwardingArgumentsNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ForwardingArgumentsNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  #
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ForwardingParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `super` keyword without parentheses or arguments.
  #
  #     super
  #     ^^^^^
  class ForwardingSuperNode < Node
    attr_reader block: BlockNode?

    def initialize: (block: BlockNode?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ForwardingSuperNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to a global variable.
  #
  #     $target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableAndWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a global variable using an operator that isn't `=`.
  #
  #     $target += value
  #     ^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader operator: Symbol

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to a global variable.
  #
  #     $target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOrWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents referencing a global variable.
  #
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a global variable in a context that doesn't have an explicit value.
  #
  #     $foo, $bar = baz
  #     ^^^^  ^^^^
  class GlobalVariableTargetNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a global variable.
  #
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Node
    attr_reader operator_loc: Location

    def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> GlobalVariableWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a hash literal.
  #
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    attr_reader opening_loc: Location
    attr_reader elements: Array[Node]
    attr_reader closing_loc: Location

    def initialize: (opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> HashNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a hash pattern in pattern matching.
  #
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  #
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  class HashPatternNode < Node
    attr_reader constant: Node?
    attr_reader elements: Array[Node]
    attr_reader rest: Node?
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (constant: Node?, elements: Array[Node], rest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> HashPatternNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `if` keyword, either in the block form or the modifier form.
  #
  #     bar if foo
  #     ^^^^^^^^^^
  #
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  class IfNode < Node
    attr_reader if_keyword_loc: Location?
    attr_reader predicate: Node
    attr_reader statements: StatementsNode?
    attr_reader consequent: Node?
    attr_reader end_keyword_loc: Location?

    def initialize: (if_keyword_loc: Location?, predicate: Node, statements: StatementsNode?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> IfNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def if_keyword: () -> String?

    def end_keyword: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an imaginary number literal.
  #
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    attr_reader numeric: Node

    def initialize: (numeric: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ImaginaryNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a node that is implicitly being added to the tree but doesn't
  # correspond directly to a node in the source.
  #
  #     { foo: }
  #       ^^^^
  #
  #     { Foo: }
  #       ^^^^
  class ImplicitNode < Node
    attr_reader value: Node

    def initialize: (value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ImplicitNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `in` keyword in a case statement.
  #
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    attr_reader pattern: Node
    attr_reader statements: StatementsNode?
    attr_reader in_loc: Location
    attr_reader then_loc: Location?

    def initialize: (pattern: Node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def in: () -> String

    def then: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator on a call to the `[]` method.
  #
  #     foo.bar[baz] &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexAndWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: Node?
    attr_reader flags: Integer
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> IndexAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def opening: () -> String

    def closing: () -> String

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of an assignment operator on a call to `[]`.
  #
  #     foo.bar[baz] += value
  #     ^^^^^^^^^^^^^^^^^^^^^
  class IndexOperatorWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: Node?
    attr_reader flags: Integer
    attr_reader operator: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> IndexOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def opening: () -> String

    def closing: () -> String

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator on a call to `[]`.
  #
  #     foo.bar[baz] ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexOrWriteNode < Node
    attr_reader receiver: Node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: Node?
    attr_reader flags: Integer
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> IndexOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def call_operator: () -> String?

    def opening: () -> String

    def closing: () -> String

    def safe_navigation?: () -> bool

    def variable_call?: () -> bool

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to an instance variable.
  #
  #     @target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableAndWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to an instance variable using an operator that isn't `=`.
  #
  #     @target += value
  #     ^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader operator: Symbol

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to an instance variable.
  #
  #     @target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOrWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents referencing an instance variable.
  #
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to an instance variable in a context that doesn't have an explicit value.
  #
  #     @foo, @bar = baz
  #     ^^^^  ^^^^
  class InstanceVariableTargetNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to an instance variable.
  #
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Node
    attr_reader operator_loc: Location

    def initialize: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InstanceVariableWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an integer number literal.
  #
  #     1
  #     ^
  class IntegerNode < Node
    attr_reader flags: Integer

    def initialize: (flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> IntegerNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def binary?: () -> bool

    def octal?: () -> bool

    def decimal?: () -> bool

    def hexadecimal?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a regular expression literal that contains interpolation that
  # is being used in the predicate of a conditional to implicitly match
  # against the last line read by an IO object.
  #
  #     if /foo #{bar} baz/ then end
  #        ^^^^^^^^^^^^^^^^
  class InterpolatedMatchLastLineNode < Node
    attr_reader opening_loc: Location
    attr_reader parts: Array[Node]
    attr_reader closing_loc: Location
    attr_reader flags: Integer

    def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InterpolatedMatchLastLineNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def ignore_case?: () -> bool

    def extended?: () -> bool

    def multi_line?: () -> bool

    def once?: () -> bool

    def euc_jp?: () -> bool

    def ascii_8bit?: () -> bool

    def windows_31j?: () -> bool

    def utf_8?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a regular expression literal that contains interpolation.
  #
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    attr_reader opening_loc: Location
    attr_reader parts: Array[Node]
    attr_reader closing_loc: Location
    attr_reader flags: Integer

    def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InterpolatedRegularExpressionNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def ignore_case?: () -> bool

    def extended?: () -> bool

    def multi_line?: () -> bool

    def once?: () -> bool

    def euc_jp?: () -> bool

    def ascii_8bit?: () -> bool

    def windows_31j?: () -> bool

    def utf_8?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a string literal that contains interpolation.
  #
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    attr_reader opening_loc: Location?
    attr_reader parts: Array[Node]
    attr_reader closing_loc: Location?

    def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InterpolatedStringNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a symbol literal that contains interpolation.
  #
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    attr_reader opening_loc: Location?
    attr_reader parts: Array[Node]
    attr_reader closing_loc: Location?

    def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InterpolatedSymbolNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an xstring literal that contains interpolation.
  #
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    attr_reader opening_loc: Location
    attr_reader parts: Array[Node]
    attr_reader closing_loc: Location

    def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> InterpolatedXStringNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a hash literal without opening and closing braces.
  #
  #     foo(a: b)
  #         ^^^^
  class KeywordHashNode < Node
    attr_reader elements: Array[Node]

    def initialize: (elements: Array[Node], location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> KeywordHashNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a keyword rest parameter to a method, block, or lambda definition.
  #
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> KeywordRestParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents using a lambda literal (not the lambda method call).
  #
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader operator_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location
    attr_reader parameters: BlockParametersNode?
    attr_reader body: Node?

    def initialize: (locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode?, body: Node?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LambdaNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `&&=` operator for assignment to a local variable.
  #
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableAndWriteNode < Node
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableAndWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents assigning to a local variable using an operator that isn't `=`.
  #
  #     target += value
  #     ^^^^^^^^^^^^^^^
  class LocalVariableOperatorWriteNode < Node
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader name: Symbol
    attr_reader operator: Symbol
    attr_reader depth: Integer

    def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableOperatorWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||=` operator for assignment to a local variable.
  #
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOrWriteNode < Node
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableOrWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents reading a local variable. Note that this requires that a local
  # variable of the same name has already been written to in the same scope,
  # otherwise it is parsed as a method call.
  #
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (name: Symbol, depth: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a local variable in a context that doesn't have an explicit value.
  #
  #     foo, bar = baz
  #     ^^^  ^^^
  class LocalVariableTargetNode < Node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (name: Symbol, depth: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing to a local variable.
  #
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    attr_reader name: Symbol
    attr_reader depth: Integer
    attr_reader name_loc: Location
    attr_reader value: Node
    attr_reader operator_loc: Location

    def initialize: (name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> LocalVariableWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a regular expression literal used in the predicate of a
  # conditional to implicitly match against the last line read by an IO
  # object.
  #
  #     if /foo/i then end
  #        ^^^^^^
  class MatchLastLineNode < Node
    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String
    attr_reader flags: Integer

    def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MatchLastLineNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def content: () -> String

    def closing: () -> String

    def ignore_case?: () -> bool

    def extended?: () -> bool

    def multi_line?: () -> bool

    def once?: () -> bool

    def euc_jp?: () -> bool

    def ascii_8bit?: () -> bool

    def windows_31j?: () -> bool

    def utf_8?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the modifier `in` operator.
  #
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    attr_reader value: Node
    attr_reader pattern: Node
    attr_reader operator_loc: Location

    def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MatchPredicateNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `=>` operator.
  #
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    attr_reader value: Node
    attr_reader pattern: Node
    attr_reader operator_loc: Location

    def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MatchRequiredNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents writing local variables using a regular expression match with
  # named capture groups.
  #
  #     /(?<foo>bar)/ =~ baz
  #     ^^^^^^^^^^^^^^^^^^^^
  class MatchWriteNode < Node
    attr_reader call: CallNode
    attr_reader locals: Array[Symbol]

    def initialize: (call: CallNode, locals: Array[Symbol], location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MatchWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a node that is missing from the source and results in a syntax
  # error.
  class MissingNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MissingNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a module declaration involving the `module` keyword.
  #
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader module_keyword_loc: Location
    attr_reader constant_path: Node
    attr_reader body: Node?
    attr_reader end_keyword_loc: Location
    attr_reader name: Symbol

    def initialize: (locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ModuleNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def module_keyword: () -> String

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a multi-target expression.
  #
  #     a, (b, c) = 1, 2, 3
  #        ^^^^^^
  class MultiTargetNode < Node
    attr_reader lefts: Array[Node]
    attr_reader rest: Node?
    attr_reader rights: Array[Node]
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?

    def initialize: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MultiTargetNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def lparen: () -> String?

    def rparen: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a write to a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    attr_reader lefts: Array[Node]
    attr_reader rest: Node?
    attr_reader rights: Array[Node]
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> MultiWriteNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def lparen: () -> String?

    def rparen: () -> String?

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `next` keyword.
  #
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    attr_reader arguments: ArgumentsNode?
    attr_reader keyword_loc: Location

    def initialize: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> NextNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `nil` keyword.
  #
  #     nil
  #     ^^^
  class NilNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> NilNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of `**nil` inside method arguments.
  #
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    attr_reader operator_loc: Location
    attr_reader keyword_loc: Location

    def initialize: (operator_loc: Location, keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> NoKeywordsParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents reading a numbered reference to a capture in the previous match.
  #
  #     $1
  #     ^^
  class NumberedReferenceReadNode < Node
    attr_reader number: Integer

    def initialize: (number: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> NumberedReferenceReadNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an optional keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: 1)
  #           ^^^^
  #     end
  class OptionalKeywordParameterNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> OptionalKeywordParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an optional parameter to a method, block, or lambda definition.
  #
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Node

    def initialize: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> OptionalParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `||` operator or the `or` keyword.
  #
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    attr_reader left: Node
    attr_reader right: Node
    attr_reader operator_loc: Location

    def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> OrNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the list of parameters on a method, block, or lambda definition.
  #
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    attr_reader requireds: Array[Node]
    attr_reader optionals: Array[Node]
    attr_reader rest: RestParameterNode?
    attr_reader posts: Array[Node]
    attr_reader keywords: Array[Node]
    attr_reader keyword_rest: Node?
    attr_reader block: BlockParameterNode?

    def initialize: (requireds: Array[Node], optionals: Array[Node], rest: RestParameterNode?, posts: Array[Node], keywords: Array[Node], keyword_rest: Node?, block: BlockParameterNode?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ParametersNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a parenthesized expression
  #
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    attr_reader body: Node?
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ParenthesesNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `^` operator for pinning an expression in a
  # pattern matching expression.
  #
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    attr_reader expression: Node
    attr_reader operator_loc: Location
    attr_reader lparen_loc: Location
    attr_reader rparen_loc: Location

    def initialize: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> PinnedExpressionNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def lparen: () -> String

    def rparen: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `^` operator for pinning a variable in a pattern
  # matching expression.
  #
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    attr_reader variable: Node
    attr_reader operator_loc: Location

    def initialize: (variable: Node, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> PinnedVariableNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `END` keyword.
  #
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    attr_reader statements: StatementsNode?
    attr_reader keyword_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> PostExecutionNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `BEGIN` keyword.
  #
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    attr_reader statements: StatementsNode?
    attr_reader keyword_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> PreExecutionNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def opening: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # The top level node of any parse tree.
  class ProgramNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader statements: StatementsNode

    def initialize: (locals: Array[Symbol], statements: StatementsNode, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ProgramNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `..` or `...` operators.
  #
  #     1..2
  #     ^^^^
  #
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    attr_reader left: Node?
    attr_reader right: Node?
    attr_reader operator_loc: Location
    attr_reader flags: Integer

    def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RangeNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def exclude_end?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a rational number literal.
  #
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    attr_reader numeric: Node

    def initialize: (numeric: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RationalNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `redo` keyword.
  #
  #     redo
  #     ^^^^
  class RedoNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RedoNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a regular expression literal with no interpolation.
  #
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String
    attr_reader flags: Integer

    def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RegularExpressionNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def content: () -> String

    def closing: () -> String

    def ignore_case?: () -> bool

    def extended?: () -> bool

    def multi_line?: () -> bool

    def once?: () -> bool

    def euc_jp?: () -> bool

    def ascii_8bit?: () -> bool

    def windows_31j?: () -> bool

    def utf_8?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a required keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: )
  #           ^^
  #     end
  class RequiredKeywordParameterNode < Node
    attr_reader name: Symbol
    attr_reader name_loc: Location

    def initialize: (name: Symbol, name_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RequiredKeywordParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a required parameter to a method, block, or lambda definition.
  #
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    attr_reader name: Symbol

    def initialize: (name: Symbol, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RequiredParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an expression modified with a rescue.
  #
  #     foo rescue nil
  #     ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    attr_reader expression: Node
    attr_reader keyword_loc: Location
    attr_reader rescue_expression: Node

    def initialize: (expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RescueModifierNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a rescue statement.
  #
  #     begin
  #     rescue Foo, *splat, Bar => ex
  #       foo
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #     end
  #
  # `Foo, *splat, Bar` are in the `exceptions` field.
  # `ex` is in the `exception` field.
  class RescueNode < Node
    attr_reader keyword_loc: Location
    attr_reader exceptions: Array[Node]
    attr_reader operator_loc: Location?
    attr_reader reference: Node?
    attr_reader statements: StatementsNode?
    attr_reader consequent: RescueNode?

    def initialize: (keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, reference: Node?, statements: StatementsNode?, consequent: RescueNode?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RescueNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def operator: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a rest parameter to a method, block, or lambda definition.
  #
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RestParameterNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `retry` keyword.
  #
  #     retry
  #     ^^^^^
  class RetryNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> RetryNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `return` keyword.
  #
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    attr_reader keyword_loc: Location
    attr_reader arguments: ArgumentsNode?

    def initialize: (keyword_loc: Location, arguments: ArgumentsNode?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> ReturnNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the `self` keyword.
  #
  #     self
  #     ^^^^
  class SelfNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SelfNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a singleton class declaration involving the `class` keyword.
  #
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    attr_reader locals: Array[Symbol]
    attr_reader class_keyword_loc: Location
    attr_reader operator_loc: Location
    attr_reader expression: Node
    attr_reader body: Node?
    attr_reader end_keyword_loc: Location

    def initialize: (locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: Node?, end_keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SingletonClassNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def class_keyword: () -> String

    def operator: () -> String

    def end_keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `__ENCODING__` keyword.
  #
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SourceEncodingNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `__FILE__` keyword.
  #
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    attr_reader filepath: String

    def initialize: (filepath: String, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SourceFileNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `__LINE__` keyword.
  #
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SourceLineNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the splat operator.
  #
  #     [*a]
  #      ^^
  class SplatNode < Node
    attr_reader operator_loc: Location
    attr_reader expression: Node?

    def initialize: (operator_loc: Location, expression: Node?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SplatNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def operator: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a set of statements contained within some scope.
  #
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    attr_reader body: Array[Node]

    def initialize: (body: Array[Node], location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> StatementsNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of compile-time string concatenation.
  #
  #     "foo" "bar"
  #     ^^^^^^^^^^^
  class StringConcatNode < Node
    attr_reader left: Node
    attr_reader right: Node

    def initialize: (left: Node, right: Node, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> StringConcatNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a string literal, a string contained within a `%w` list, or
  # plain string content within an interpolated string.
  #
  #     "foo"
  #     ^^^^^
  #
  #     %w[foo]
  #        ^^^
  #
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    attr_reader flags: Integer
    attr_reader opening_loc: Location?
    attr_reader content_loc: Location
    attr_reader closing_loc: Location?
    attr_reader unescaped: String

    def initialize: (flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> StringNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def frozen?: () -> bool

    def opening: () -> String?

    def content: () -> String

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `super` keyword with parentheses or arguments.
  #
  #     super()
  #     ^^^^^^^
  #
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  class SuperNode < Node
    attr_reader keyword_loc: Location
    attr_reader lparen_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader rparen_loc: Location?
    attr_reader block: Node?

    def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Node?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SuperNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def lparen: () -> String?

    def rparen: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents a symbol literal or a symbol contained within a `%i` list.
  #
  #     :foo
  #     ^^^^
  #
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    attr_reader opening_loc: Location?
    attr_reader value_loc: Location?
    attr_reader closing_loc: Location?
    attr_reader unescaped: String

    def initialize: (opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> SymbolNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String?

    def value: () -> String?

    def closing: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the literal `true` keyword.
  #
  #     true
  #     ^^^^
  class TrueNode < Node

    def initialize: (location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> TrueNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `undef` keyword.
  #
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    attr_reader names: Array[Node]
    attr_reader keyword_loc: Location

    def initialize: (names: Array[Node], keyword_loc: Location, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> UndefNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  #
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  #
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    attr_reader keyword_loc: Location
    attr_reader predicate: Node
    attr_reader statements: StatementsNode?
    attr_reader consequent: ElseNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (keyword_loc: Location, predicate: Node, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> UnlessNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def end_keyword: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  #
  #     bar until foo
  #     ^^^^^^^^^^^^^
  #
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    attr_reader keyword_loc: Location
    attr_reader closing_loc: Location?
    attr_reader predicate: Node
    attr_reader statements: StatementsNode?
    attr_reader flags: Integer

    def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> UntilNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def closing: () -> String?

    def begin_modifier?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `when` keyword within a case statement.
  #
  #     case true
  #     when true
  #     ^^^^^^^^^
  #     end
  class WhenNode < Node
    attr_reader keyword_loc: Location
    attr_reader conditions: Array[Node]
    attr_reader statements: StatementsNode?

    def initialize: (keyword_loc: Location, conditions: Array[Node], statements: StatementsNode?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> WhenNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  #
  #     bar while foo
  #     ^^^^^^^^^^^^^
  #
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    attr_reader keyword_loc: Location
    attr_reader closing_loc: Location?
    attr_reader predicate: Node
    attr_reader statements: StatementsNode?
    attr_reader flags: Integer

    def initialize: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> WhileNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def closing: () -> String?

    def begin_modifier?: () -> bool

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents an xstring literal with no interpolation.
  #
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String

    def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> XStringNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def opening: () -> String

    def content: () -> String

    def closing: () -> String

    def inspect: (inspector: NodeInspector) -> String
  end
  # Represents the use of the `yield` keyword.
  #
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    attr_reader keyword_loc: Location
    attr_reader lparen_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader rparen_loc: Location?

    def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location) -> void
    def accept: (visitor: Visitor) -> void
    def set_newline_flag: (newline_marked: Array[bool]) -> void
    def child_nodes: () -> Array[Node?]
    def deconstruct: () -> Array[Node?]

    def copy: (**untyped) -> YieldNode

    def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, (Node | Array[Node] | String | Token | Array[Token] | Location)?]

    def keyword: () -> String

    def lparen: () -> String?

    def rparen: () -> String?

    def inspect: (inspector: NodeInspector) -> String
  end

  # Flags for arguments nodes.
  module ArgumentsNodeFlags
    # if arguments contain keyword splat
    KEYWORD_SPLAT: Integer
  end

  # Flags for call nodes.
  module CallNodeFlags
    # &. operator
    SAFE_NAVIGATION: Integer
    # a call that could have been a local variable
    VARIABLE_CALL: Integer
  end

  # Flags for integer nodes that correspond to the base of the integer.
  module IntegerBaseFlags
    # 0b prefix
    BINARY: Integer
    # 0o or 0 prefix
    OCTAL: Integer
    # 0d or no prefix
    DECIMAL: Integer
    # 0x prefix
    HEXADECIMAL: Integer
  end

  # Flags for while and until loop nodes.
  module LoopFlags
    # a loop after a begin statement, so the body is executed first before the condition
    BEGIN_MODIFIER: Integer
  end

  # Flags for range and flip-flop nodes.
  module RangeFlags
    # ... operator
    EXCLUDE_END: Integer
  end

  # Flags for regular expression and match last line nodes.
  module RegularExpressionFlags
    # i - ignores the case of characters when matching
    IGNORE_CASE: Integer
    # x - ignores whitespace and allows comments in regular expressions
    EXTENDED: Integer
    # m - allows $ to match the end of lines within strings
    MULTI_LINE: Integer
    # o - only interpolates values into the regular expression once
    ONCE: Integer
    # e - forces the EUC-JP encoding
    EUC_JP: Integer
    # n - forces the ASCII-8BIT encoding
    ASCII_8BIT: Integer
    # s - forces the Windows-31J encoding
    WINDOWS_31J: Integer
    # u - forces the UTF-8 encoding
    UTF_8: Integer
  end

  # Flags for string nodes.
  module StringFlags
    # frozen by virtue of a `frozen_string_literal` comment
    FROZEN: Integer
  end


  class Visitor < BasicVisitor
    # Visit a AliasGlobalVariableNode node
    def visit_alias_global_variable_node: (node: AliasGlobalVariableNode) -> void
    
    # Visit a AliasMethodNode node
    def visit_alias_method_node: (node: AliasMethodNode) -> void
    
    # Visit a AlternationPatternNode node
    def visit_alternation_pattern_node: (node: AlternationPatternNode) -> void
    
    # Visit a AndNode node
    def visit_and_node: (node: AndNode) -> void
    
    # Visit a ArgumentsNode node
    def visit_arguments_node: (node: ArgumentsNode) -> void
    
    # Visit a ArrayNode node
    def visit_array_node: (node: ArrayNode) -> void
    
    # Visit a ArrayPatternNode node
    def visit_array_pattern_node: (node: ArrayPatternNode) -> void
    
    # Visit a AssocNode node
    def visit_assoc_node: (node: AssocNode) -> void
    
    # Visit a AssocSplatNode node
    def visit_assoc_splat_node: (node: AssocSplatNode) -> void
    
    # Visit a BackReferenceReadNode node
    def visit_back_reference_read_node: (node: BackReferenceReadNode) -> void
    
    # Visit a BeginNode node
    def visit_begin_node: (node: BeginNode) -> void
    
    # Visit a BlockArgumentNode node
    def visit_block_argument_node: (node: BlockArgumentNode) -> void
    
    # Visit a BlockLocalVariableNode node
    def visit_block_local_variable_node: (node: BlockLocalVariableNode) -> void
    
    # Visit a BlockNode node
    def visit_block_node: (node: BlockNode) -> void
    
    # Visit a BlockParameterNode node
    def visit_block_parameter_node: (node: BlockParameterNode) -> void
    
    # Visit a BlockParametersNode node
    def visit_block_parameters_node: (node: BlockParametersNode) -> void
    
    # Visit a BreakNode node
    def visit_break_node: (node: BreakNode) -> void
    
    # Visit a CallAndWriteNode node
    def visit_call_and_write_node: (node: CallAndWriteNode) -> void
    
    # Visit a CallNode node
    def visit_call_node: (node: CallNode) -> void
    
    # Visit a CallOperatorWriteNode node
    def visit_call_operator_write_node: (node: CallOperatorWriteNode) -> void
    
    # Visit a CallOrWriteNode node
    def visit_call_or_write_node: (node: CallOrWriteNode) -> void
    
    # Visit a CapturePatternNode node
    def visit_capture_pattern_node: (node: CapturePatternNode) -> void
    
    # Visit a CaseNode node
    def visit_case_node: (node: CaseNode) -> void
    
    # Visit a ClassNode node
    def visit_class_node: (node: ClassNode) -> void
    
    # Visit a ClassVariableAndWriteNode node
    def visit_class_variable_and_write_node: (node: ClassVariableAndWriteNode) -> void
    
    # Visit a ClassVariableOperatorWriteNode node
    def visit_class_variable_operator_write_node: (node: ClassVariableOperatorWriteNode) -> void
    
    # Visit a ClassVariableOrWriteNode node
    def visit_class_variable_or_write_node: (node: ClassVariableOrWriteNode) -> void
    
    # Visit a ClassVariableReadNode node
    def visit_class_variable_read_node: (node: ClassVariableReadNode) -> void
    
    # Visit a ClassVariableTargetNode node
    def visit_class_variable_target_node: (node: ClassVariableTargetNode) -> void
    
    # Visit a ClassVariableWriteNode node
    def visit_class_variable_write_node: (node: ClassVariableWriteNode) -> void
    
    # Visit a ConstantAndWriteNode node
    def visit_constant_and_write_node: (node: ConstantAndWriteNode) -> void
    
    # Visit a ConstantOperatorWriteNode node
    def visit_constant_operator_write_node: (node: ConstantOperatorWriteNode) -> void
    
    # Visit a ConstantOrWriteNode node
    def visit_constant_or_write_node: (node: ConstantOrWriteNode) -> void
    
    # Visit a ConstantPathAndWriteNode node
    def visit_constant_path_and_write_node: (node: ConstantPathAndWriteNode) -> void
    
    # Visit a ConstantPathNode node
    def visit_constant_path_node: (node: ConstantPathNode) -> void
    
    # Visit a ConstantPathOperatorWriteNode node
    def visit_constant_path_operator_write_node: (node: ConstantPathOperatorWriteNode) -> void
    
    # Visit a ConstantPathOrWriteNode node
    def visit_constant_path_or_write_node: (node: ConstantPathOrWriteNode) -> void
    
    # Visit a ConstantPathTargetNode node
    def visit_constant_path_target_node: (node: ConstantPathTargetNode) -> void
    
    # Visit a ConstantPathWriteNode node
    def visit_constant_path_write_node: (node: ConstantPathWriteNode) -> void
    
    # Visit a ConstantReadNode node
    def visit_constant_read_node: (node: ConstantReadNode) -> void
    
    # Visit a ConstantTargetNode node
    def visit_constant_target_node: (node: ConstantTargetNode) -> void
    
    # Visit a ConstantWriteNode node
    def visit_constant_write_node: (node: ConstantWriteNode) -> void
    
    # Visit a DefNode node
    def visit_def_node: (node: DefNode) -> void
    
    # Visit a DefinedNode node
    def visit_defined_node: (node: DefinedNode) -> void
    
    # Visit a ElseNode node
    def visit_else_node: (node: ElseNode) -> void
    
    # Visit a EmbeddedStatementsNode node
    def visit_embedded_statements_node: (node: EmbeddedStatementsNode) -> void
    
    # Visit a EmbeddedVariableNode node
    def visit_embedded_variable_node: (node: EmbeddedVariableNode) -> void
    
    # Visit a EnsureNode node
    def visit_ensure_node: (node: EnsureNode) -> void
    
    # Visit a FalseNode node
    def visit_false_node: (node: FalseNode) -> void
    
    # Visit a FindPatternNode node
    def visit_find_pattern_node: (node: FindPatternNode) -> void
    
    # Visit a FlipFlopNode node
    def visit_flip_flop_node: (node: FlipFlopNode) -> void
    
    # Visit a FloatNode node
    def visit_float_node: (node: FloatNode) -> void
    
    # Visit a ForNode node
    def visit_for_node: (node: ForNode) -> void
    
    # Visit a ForwardingArgumentsNode node
    def visit_forwarding_arguments_node: (node: ForwardingArgumentsNode) -> void
    
    # Visit a ForwardingParameterNode node
    def visit_forwarding_parameter_node: (node: ForwardingParameterNode) -> void
    
    # Visit a ForwardingSuperNode node
    def visit_forwarding_super_node: (node: ForwardingSuperNode) -> void
    
    # Visit a GlobalVariableAndWriteNode node
    def visit_global_variable_and_write_node: (node: GlobalVariableAndWriteNode) -> void
    
    # Visit a GlobalVariableOperatorWriteNode node
    def visit_global_variable_operator_write_node: (node: GlobalVariableOperatorWriteNode) -> void
    
    # Visit a GlobalVariableOrWriteNode node
    def visit_global_variable_or_write_node: (node: GlobalVariableOrWriteNode) -> void
    
    # Visit a GlobalVariableReadNode node
    def visit_global_variable_read_node: (node: GlobalVariableReadNode) -> void
    
    # Visit a GlobalVariableTargetNode node
    def visit_global_variable_target_node: (node: GlobalVariableTargetNode) -> void
    
    # Visit a GlobalVariableWriteNode node
    def visit_global_variable_write_node: (node: GlobalVariableWriteNode) -> void
    
    # Visit a HashNode node
    def visit_hash_node: (node: HashNode) -> void
    
    # Visit a HashPatternNode node
    def visit_hash_pattern_node: (node: HashPatternNode) -> void
    
    # Visit a IfNode node
    def visit_if_node: (node: IfNode) -> void
    
    # Visit a ImaginaryNode node
    def visit_imaginary_node: (node: ImaginaryNode) -> void
    
    # Visit a ImplicitNode node
    def visit_implicit_node: (node: ImplicitNode) -> void
    
    # Visit a InNode node
    def visit_in_node: (node: InNode) -> void
    
    # Visit a IndexAndWriteNode node
    def visit_index_and_write_node: (node: IndexAndWriteNode) -> void
    
    # Visit a IndexOperatorWriteNode node
    def visit_index_operator_write_node: (node: IndexOperatorWriteNode) -> void
    
    # Visit a IndexOrWriteNode node
    def visit_index_or_write_node: (node: IndexOrWriteNode) -> void
    
    # Visit a InstanceVariableAndWriteNode node
    def visit_instance_variable_and_write_node: (node: InstanceVariableAndWriteNode) -> void
    
    # Visit a InstanceVariableOperatorWriteNode node
    def visit_instance_variable_operator_write_node: (node: InstanceVariableOperatorWriteNode) -> void
    
    # Visit a InstanceVariableOrWriteNode node
    def visit_instance_variable_or_write_node: (node: InstanceVariableOrWriteNode) -> void
    
    # Visit a InstanceVariableReadNode node
    def visit_instance_variable_read_node: (node: InstanceVariableReadNode) -> void
    
    # Visit a InstanceVariableTargetNode node
    def visit_instance_variable_target_node: (node: InstanceVariableTargetNode) -> void
    
    # Visit a InstanceVariableWriteNode node
    def visit_instance_variable_write_node: (node: InstanceVariableWriteNode) -> void
    
    # Visit a IntegerNode node
    def visit_integer_node: (node: IntegerNode) -> void
    
    # Visit a InterpolatedMatchLastLineNode node
    def visit_interpolated_match_last_line_node: (node: InterpolatedMatchLastLineNode) -> void
    
    # Visit a InterpolatedRegularExpressionNode node
    def visit_interpolated_regular_expression_node: (node: InterpolatedRegularExpressionNode) -> void
    
    # Visit a InterpolatedStringNode node
    def visit_interpolated_string_node: (node: InterpolatedStringNode) -> void
    
    # Visit a InterpolatedSymbolNode node
    def visit_interpolated_symbol_node: (node: InterpolatedSymbolNode) -> void
    
    # Visit a InterpolatedXStringNode node
    def visit_interpolated_x_string_node: (node: InterpolatedXStringNode) -> void
    
    # Visit a KeywordHashNode node
    def visit_keyword_hash_node: (node: KeywordHashNode) -> void
    
    # Visit a KeywordRestParameterNode node
    def visit_keyword_rest_parameter_node: (node: KeywordRestParameterNode) -> void
    
    # Visit a LambdaNode node
    def visit_lambda_node: (node: LambdaNode) -> void
    
    # Visit a LocalVariableAndWriteNode node
    def visit_local_variable_and_write_node: (node: LocalVariableAndWriteNode) -> void
    
    # Visit a LocalVariableOperatorWriteNode node
    def visit_local_variable_operator_write_node: (node: LocalVariableOperatorWriteNode) -> void
    
    # Visit a LocalVariableOrWriteNode node
    def visit_local_variable_or_write_node: (node: LocalVariableOrWriteNode) -> void
    
    # Visit a LocalVariableReadNode node
    def visit_local_variable_read_node: (node: LocalVariableReadNode) -> void
    
    # Visit a LocalVariableTargetNode node
    def visit_local_variable_target_node: (node: LocalVariableTargetNode) -> void
    
    # Visit a LocalVariableWriteNode node
    def visit_local_variable_write_node: (node: LocalVariableWriteNode) -> void
    
    # Visit a MatchLastLineNode node
    def visit_match_last_line_node: (node: MatchLastLineNode) -> void
    
    # Visit a MatchPredicateNode node
    def visit_match_predicate_node: (node: MatchPredicateNode) -> void
    
    # Visit a MatchRequiredNode node
    def visit_match_required_node: (node: MatchRequiredNode) -> void
    
    # Visit a MatchWriteNode node
    def visit_match_write_node: (node: MatchWriteNode) -> void
    
    # Visit a MissingNode node
    def visit_missing_node: (node: MissingNode) -> void
    
    # Visit a ModuleNode node
    def visit_module_node: (node: ModuleNode) -> void
    
    # Visit a MultiTargetNode node
    def visit_multi_target_node: (node: MultiTargetNode) -> void
    
    # Visit a MultiWriteNode node
    def visit_multi_write_node: (node: MultiWriteNode) -> void
    
    # Visit a NextNode node
    def visit_next_node: (node: NextNode) -> void
    
    # Visit a NilNode node
    def visit_nil_node: (node: NilNode) -> void
    
    # Visit a NoKeywordsParameterNode node
    def visit_no_keywords_parameter_node: (node: NoKeywordsParameterNode) -> void
    
    # Visit a NumberedReferenceReadNode node
    def visit_numbered_reference_read_node: (node: NumberedReferenceReadNode) -> void
    
    # Visit a OptionalKeywordParameterNode node
    def visit_optional_keyword_parameter_node: (node: OptionalKeywordParameterNode) -> void
    
    # Visit a OptionalParameterNode node
    def visit_optional_parameter_node: (node: OptionalParameterNode) -> void
    
    # Visit a OrNode node
    def visit_or_node: (node: OrNode) -> void
    
    # Visit a ParametersNode node
    def visit_parameters_node: (node: ParametersNode) -> void
    
    # Visit a ParenthesesNode node
    def visit_parentheses_node: (node: ParenthesesNode) -> void
    
    # Visit a PinnedExpressionNode node
    def visit_pinned_expression_node: (node: PinnedExpressionNode) -> void
    
    # Visit a PinnedVariableNode node
    def visit_pinned_variable_node: (node: PinnedVariableNode) -> void
    
    # Visit a PostExecutionNode node
    def visit_post_execution_node: (node: PostExecutionNode) -> void
    
    # Visit a PreExecutionNode node
    def visit_pre_execution_node: (node: PreExecutionNode) -> void
    
    # Visit a ProgramNode node
    def visit_program_node: (node: ProgramNode) -> void
    
    # Visit a RangeNode node
    def visit_range_node: (node: RangeNode) -> void
    
    # Visit a RationalNode node
    def visit_rational_node: (node: RationalNode) -> void
    
    # Visit a RedoNode node
    def visit_redo_node: (node: RedoNode) -> void
    
    # Visit a RegularExpressionNode node
    def visit_regular_expression_node: (node: RegularExpressionNode) -> void
    
    # Visit a RequiredKeywordParameterNode node
    def visit_required_keyword_parameter_node: (node: RequiredKeywordParameterNode) -> void
    
    # Visit a RequiredParameterNode node
    def visit_required_parameter_node: (node: RequiredParameterNode) -> void
    
    # Visit a RescueModifierNode node
    def visit_rescue_modifier_node: (node: RescueModifierNode) -> void
    
    # Visit a RescueNode node
    def visit_rescue_node: (node: RescueNode) -> void
    
    # Visit a RestParameterNode node
    def visit_rest_parameter_node: (node: RestParameterNode) -> void
    
    # Visit a RetryNode node
    def visit_retry_node: (node: RetryNode) -> void
    
    # Visit a ReturnNode node
    def visit_return_node: (node: ReturnNode) -> void
    
    # Visit a SelfNode node
    def visit_self_node: (node: SelfNode) -> void
    
    # Visit a SingletonClassNode node
    def visit_singleton_class_node: (node: SingletonClassNode) -> void
    
    # Visit a SourceEncodingNode node
    def visit_source_encoding_node: (node: SourceEncodingNode) -> void
    
    # Visit a SourceFileNode node
    def visit_source_file_node: (node: SourceFileNode) -> void
    
    # Visit a SourceLineNode node
    def visit_source_line_node: (node: SourceLineNode) -> void
    
    # Visit a SplatNode node
    def visit_splat_node: (node: SplatNode) -> void
    
    # Visit a StatementsNode node
    def visit_statements_node: (node: StatementsNode) -> void
    
    # Visit a StringConcatNode node
    def visit_string_concat_node: (node: StringConcatNode) -> void
    
    # Visit a StringNode node
    def visit_string_node: (node: StringNode) -> void
    
    # Visit a SuperNode node
    def visit_super_node: (node: SuperNode) -> void
    
    # Visit a SymbolNode node
    def visit_symbol_node: (node: SymbolNode) -> void
    
    # Visit a TrueNode node
    def visit_true_node: (node: TrueNode) -> void
    
    # Visit a UndefNode node
    def visit_undef_node: (node: UndefNode) -> void
    
    # Visit a UnlessNode node
    def visit_unless_node: (node: UnlessNode) -> void
    
    # Visit a UntilNode node
    def visit_until_node: (node: UntilNode) -> void
    
    # Visit a WhenNode node
    def visit_when_node: (node: WhenNode) -> void
    
    # Visit a WhileNode node
    def visit_while_node: (node: WhileNode) -> void
    
    # Visit a XStringNode node
    def visit_x_string_node: (node: XStringNode) -> void
    
    # Visit a YieldNode node
    def visit_yield_node: (node: YieldNode) -> void
      end

  module DSL
    private

    # Create a new Location object
    def Location: (source: Source?, start_offset: Integer, length: Integer) -> Location

    # Create a new AliasGlobalVariableNode node
    def AliasGlobalVariableNode: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> AliasGlobalVariableNode
    # Create a new AliasMethodNode node
    def AliasMethodNode: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> AliasMethodNode
    # Create a new AlternationPatternNode node
    def AlternationPatternNode: (left: Node, right: Node, operator_loc: Location, location: Location) -> AlternationPatternNode
    # Create a new AndNode node
    def AndNode: (left: Node, right: Node, operator_loc: Location, location: Location) -> AndNode
    # Create a new ArgumentsNode node
    def ArgumentsNode: (arguments: Array[Node], flags: Integer, location: Location) -> ArgumentsNode
    # Create a new ArrayNode node
    def ArrayNode: (elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> ArrayNode
    # Create a new ArrayPatternNode node
    def ArrayPatternNode: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> ArrayPatternNode
    # Create a new AssocNode node
    def AssocNode: (key: Node, value: Node?, operator_loc: Location?, location: Location) -> AssocNode
    # Create a new AssocSplatNode node
    def AssocSplatNode: (value: Node?, operator_loc: Location, location: Location) -> AssocSplatNode
    # Create a new BackReferenceReadNode node
    def BackReferenceReadNode: (name: Symbol, location: Location) -> BackReferenceReadNode
    # Create a new BeginNode node
    def BeginNode: (begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location?, location: Location) -> BeginNode
    # Create a new BlockArgumentNode node
    def BlockArgumentNode: (expression: Node?, operator_loc: Location, location: Location) -> BlockArgumentNode
    # Create a new BlockLocalVariableNode node
    def BlockLocalVariableNode: (name: Symbol, location: Location) -> BlockLocalVariableNode
    # Create a new BlockNode node
    def BlockNode: (locals: Array[Symbol], parameters: BlockParametersNode?, body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> BlockNode
    # Create a new BlockParameterNode node
    def BlockParameterNode: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> BlockParameterNode
    # Create a new BlockParametersNode node
    def BlockParametersNode: (parameters: ParametersNode?, locals: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> BlockParametersNode
    # Create a new BreakNode node
    def BreakNode: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> BreakNode
    # Create a new CallAndWriteNode node
    def CallAndWriteNode: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> CallAndWriteNode
    # Create a new CallNode node
    def CallNode: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: Node?, flags: Integer, name: Symbol, location: Location) -> CallNode
    # Create a new CallOperatorWriteNode node
    def CallOperatorWriteNode: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> CallOperatorWriteNode
    # Create a new CallOrWriteNode node
    def CallOrWriteNode: (receiver: Node?, call_operator_loc: Location?, message_loc: Location?, flags: Integer, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Node, location: Location) -> CallOrWriteNode
    # Create a new CapturePatternNode node
    def CapturePatternNode: (value: Node, target: Node, operator_loc: Location, location: Location) -> CapturePatternNode
    # Create a new CaseNode node
    def CaseNode: (predicate: Node?, conditions: Array[Node], consequent: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> CaseNode
    # Create a new ClassNode node
    def ClassNode: (locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> ClassNode
    # Create a new ClassVariableAndWriteNode node
    def ClassVariableAndWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> ClassVariableAndWriteNode
    # Create a new ClassVariableOperatorWriteNode node
    def ClassVariableOperatorWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> ClassVariableOperatorWriteNode
    # Create a new ClassVariableOrWriteNode node
    def ClassVariableOrWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> ClassVariableOrWriteNode
    # Create a new ClassVariableReadNode node
    def ClassVariableReadNode: (name: Symbol, location: Location) -> ClassVariableReadNode
    # Create a new ClassVariableTargetNode node
    def ClassVariableTargetNode: (name: Symbol, location: Location) -> ClassVariableTargetNode
    # Create a new ClassVariableWriteNode node
    def ClassVariableWriteNode: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location?, location: Location) -> ClassVariableWriteNode
    # Create a new ConstantAndWriteNode node
    def ConstantAndWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> ConstantAndWriteNode
    # Create a new ConstantOperatorWriteNode node
    def ConstantOperatorWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> ConstantOperatorWriteNode
    # Create a new ConstantOrWriteNode node
    def ConstantOrWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> ConstantOrWriteNode
    # Create a new ConstantPathAndWriteNode node
    def ConstantPathAndWriteNode: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> ConstantPathAndWriteNode
    # Create a new ConstantPathNode node
    def ConstantPathNode: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> ConstantPathNode
    # Create a new ConstantPathOperatorWriteNode node
    def ConstantPathOperatorWriteNode: (target: ConstantPathNode, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> ConstantPathOperatorWriteNode
    # Create a new ConstantPathOrWriteNode node
    def ConstantPathOrWriteNode: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> ConstantPathOrWriteNode
    # Create a new ConstantPathTargetNode node
    def ConstantPathTargetNode: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> ConstantPathTargetNode
    # Create a new ConstantPathWriteNode node
    def ConstantPathWriteNode: (target: ConstantPathNode, operator_loc: Location, value: Node, location: Location) -> ConstantPathWriteNode
    # Create a new ConstantReadNode node
    def ConstantReadNode: (name: Symbol, location: Location) -> ConstantReadNode
    # Create a new ConstantTargetNode node
    def ConstantTargetNode: (name: Symbol, location: Location) -> ConstantTargetNode
    # Create a new ConstantWriteNode node
    def ConstantWriteNode: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> ConstantWriteNode
    # Create a new DefNode node
    def DefNode: (name: Symbol, name_loc: Location, receiver: Node?, parameters: ParametersNode?, body: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> DefNode
    # Create a new DefinedNode node
    def DefinedNode: (lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location) -> DefinedNode
    # Create a new ElseNode node
    def ElseNode: (else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location?, location: Location) -> ElseNode
    # Create a new EmbeddedStatementsNode node
    def EmbeddedStatementsNode: (opening_loc: Location, statements: StatementsNode?, closing_loc: Location, location: Location) -> EmbeddedStatementsNode
    # Create a new EmbeddedVariableNode node
    def EmbeddedVariableNode: (operator_loc: Location, variable: Node, location: Location) -> EmbeddedVariableNode
    # Create a new EnsureNode node
    def EnsureNode: (ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location, location: Location) -> EnsureNode
    # Create a new FalseNode node
    def FalseNode: (location: Location) -> FalseNode
    # Create a new FindPatternNode node
    def FindPatternNode: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> FindPatternNode
    # Create a new FlipFlopNode node
    def FlipFlopNode: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> FlipFlopNode
    # Create a new FloatNode node
    def FloatNode: (location: Location) -> FloatNode
    # Create a new ForNode node
    def ForNode: (index: Node, collection: Node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> ForNode
    # Create a new ForwardingArgumentsNode node
    def ForwardingArgumentsNode: (location: Location) -> ForwardingArgumentsNode
    # Create a new ForwardingParameterNode node
    def ForwardingParameterNode: (location: Location) -> ForwardingParameterNode
    # Create a new ForwardingSuperNode node
    def ForwardingSuperNode: (block: BlockNode?, location: Location) -> ForwardingSuperNode
    # Create a new GlobalVariableAndWriteNode node
    def GlobalVariableAndWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> GlobalVariableAndWriteNode
    # Create a new GlobalVariableOperatorWriteNode node
    def GlobalVariableOperatorWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> GlobalVariableOperatorWriteNode
    # Create a new GlobalVariableOrWriteNode node
    def GlobalVariableOrWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> GlobalVariableOrWriteNode
    # Create a new GlobalVariableReadNode node
    def GlobalVariableReadNode: (name: Symbol, location: Location) -> GlobalVariableReadNode
    # Create a new GlobalVariableTargetNode node
    def GlobalVariableTargetNode: (name: Symbol, location: Location) -> GlobalVariableTargetNode
    # Create a new GlobalVariableWriteNode node
    def GlobalVariableWriteNode: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> GlobalVariableWriteNode
    # Create a new HashNode node
    def HashNode: (opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location) -> HashNode
    # Create a new HashPatternNode node
    def HashPatternNode: (constant: Node?, elements: Array[Node], rest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> HashPatternNode
    # Create a new IfNode node
    def IfNode: (if_keyword_loc: Location?, predicate: Node, statements: StatementsNode?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> IfNode
    # Create a new ImaginaryNode node
    def ImaginaryNode: (numeric: Node, location: Location) -> ImaginaryNode
    # Create a new ImplicitNode node
    def ImplicitNode: (value: Node, location: Location) -> ImplicitNode
    # Create a new InNode node
    def InNode: (pattern: Node, statements: StatementsNode?, in_loc: Location, then_loc: Location?, location: Location) -> InNode
    # Create a new IndexAndWriteNode node
    def IndexAndWriteNode: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> IndexAndWriteNode
    # Create a new IndexOperatorWriteNode node
    def IndexOperatorWriteNode: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator: Symbol, operator_loc: Location, value: Node, location: Location) -> IndexOperatorWriteNode
    # Create a new IndexOrWriteNode node
    def IndexOrWriteNode: (receiver: Node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: Node?, flags: Integer, operator_loc: Location, value: Node, location: Location) -> IndexOrWriteNode
    # Create a new InstanceVariableAndWriteNode node
    def InstanceVariableAndWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> InstanceVariableAndWriteNode
    # Create a new InstanceVariableOperatorWriteNode node
    def InstanceVariableOperatorWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> InstanceVariableOperatorWriteNode
    # Create a new InstanceVariableOrWriteNode node
    def InstanceVariableOrWriteNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> InstanceVariableOrWriteNode
    # Create a new InstanceVariableReadNode node
    def InstanceVariableReadNode: (name: Symbol, location: Location) -> InstanceVariableReadNode
    # Create a new InstanceVariableTargetNode node
    def InstanceVariableTargetNode: (name: Symbol, location: Location) -> InstanceVariableTargetNode
    # Create a new InstanceVariableWriteNode node
    def InstanceVariableWriteNode: (name: Symbol, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> InstanceVariableWriteNode
    # Create a new IntegerNode node
    def IntegerNode: (flags: Integer, location: Location) -> IntegerNode
    # Create a new InterpolatedMatchLastLineNode node
    def InterpolatedMatchLastLineNode: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> InterpolatedMatchLastLineNode
    # Create a new InterpolatedRegularExpressionNode node
    def InterpolatedRegularExpressionNode: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> InterpolatedRegularExpressionNode
    # Create a new InterpolatedStringNode node
    def InterpolatedStringNode: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> InterpolatedStringNode
    # Create a new InterpolatedSymbolNode node
    def InterpolatedSymbolNode: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> InterpolatedSymbolNode
    # Create a new InterpolatedXStringNode node
    def InterpolatedXStringNode: (opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location) -> InterpolatedXStringNode
    # Create a new KeywordHashNode node
    def KeywordHashNode: (elements: Array[Node], location: Location) -> KeywordHashNode
    # Create a new KeywordRestParameterNode node
    def KeywordRestParameterNode: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> KeywordRestParameterNode
    # Create a new LambdaNode node
    def LambdaNode: (locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode?, body: Node?, location: Location) -> LambdaNode
    # Create a new LocalVariableAndWriteNode node
    def LocalVariableAndWriteNode: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> LocalVariableAndWriteNode
    # Create a new LocalVariableOperatorWriteNode node
    def LocalVariableOperatorWriteNode: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, operator: Symbol, depth: Integer, location: Location) -> LocalVariableOperatorWriteNode
    # Create a new LocalVariableOrWriteNode node
    def LocalVariableOrWriteNode: (name_loc: Location, operator_loc: Location, value: Node, name: Symbol, depth: Integer, location: Location) -> LocalVariableOrWriteNode
    # Create a new LocalVariableReadNode node
    def LocalVariableReadNode: (name: Symbol, depth: Integer, location: Location) -> LocalVariableReadNode
    # Create a new LocalVariableTargetNode node
    def LocalVariableTargetNode: (name: Symbol, depth: Integer, location: Location) -> LocalVariableTargetNode
    # Create a new LocalVariableWriteNode node
    def LocalVariableWriteNode: (name: Symbol, depth: Integer, name_loc: Location, value: Node, operator_loc: Location, location: Location) -> LocalVariableWriteNode
    # Create a new MatchLastLineNode node
    def MatchLastLineNode: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> MatchLastLineNode
    # Create a new MatchPredicateNode node
    def MatchPredicateNode: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> MatchPredicateNode
    # Create a new MatchRequiredNode node
    def MatchRequiredNode: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> MatchRequiredNode
    # Create a new MatchWriteNode node
    def MatchWriteNode: (call: CallNode, locals: Array[Symbol], location: Location) -> MatchWriteNode
    # Create a new MissingNode node
    def MissingNode: (location: Location) -> MissingNode
    # Create a new ModuleNode node
    def ModuleNode: (locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, body: Node?, end_keyword_loc: Location, name: Symbol, location: Location) -> ModuleNode
    # Create a new MultiTargetNode node
    def MultiTargetNode: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, location: Location) -> MultiTargetNode
    # Create a new MultiWriteNode node
    def MultiWriteNode: (lefts: Array[Node], rest: Node?, rights: Array[Node], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Node, location: Location) -> MultiWriteNode
    # Create a new NextNode node
    def NextNode: (arguments: ArgumentsNode?, keyword_loc: Location, location: Location) -> NextNode
    # Create a new NilNode node
    def NilNode: (location: Location) -> NilNode
    # Create a new NoKeywordsParameterNode node
    def NoKeywordsParameterNode: (operator_loc: Location, keyword_loc: Location, location: Location) -> NoKeywordsParameterNode
    # Create a new NumberedReferenceReadNode node
    def NumberedReferenceReadNode: (number: Integer, location: Location) -> NumberedReferenceReadNode
    # Create a new OptionalKeywordParameterNode node
    def OptionalKeywordParameterNode: (name: Symbol, name_loc: Location, value: Node, location: Location) -> OptionalKeywordParameterNode
    # Create a new OptionalParameterNode node
    def OptionalParameterNode: (name: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> OptionalParameterNode
    # Create a new OrNode node
    def OrNode: (left: Node, right: Node, operator_loc: Location, location: Location) -> OrNode
    # Create a new ParametersNode node
    def ParametersNode: (requireds: Array[Node], optionals: Array[Node], rest: RestParameterNode?, posts: Array[Node], keywords: Array[Node], keyword_rest: Node?, block: BlockParameterNode?, location: Location) -> ParametersNode
    # Create a new ParenthesesNode node
    def ParenthesesNode: (body: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> ParenthesesNode
    # Create a new PinnedExpressionNode node
    def PinnedExpressionNode: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> PinnedExpressionNode
    # Create a new PinnedVariableNode node
    def PinnedVariableNode: (variable: Node, operator_loc: Location, location: Location) -> PinnedVariableNode
    # Create a new PostExecutionNode node
    def PostExecutionNode: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> PostExecutionNode
    # Create a new PreExecutionNode node
    def PreExecutionNode: (statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> PreExecutionNode
    # Create a new ProgramNode node
    def ProgramNode: (locals: Array[Symbol], statements: StatementsNode, location: Location) -> ProgramNode
    # Create a new RangeNode node
    def RangeNode: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> RangeNode
    # Create a new RationalNode node
    def RationalNode: (numeric: Node, location: Location) -> RationalNode
    # Create a new RedoNode node
    def RedoNode: (location: Location) -> RedoNode
    # Create a new RegularExpressionNode node
    def RegularExpressionNode: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> RegularExpressionNode
    # Create a new RequiredKeywordParameterNode node
    def RequiredKeywordParameterNode: (name: Symbol, name_loc: Location, location: Location) -> RequiredKeywordParameterNode
    # Create a new RequiredParameterNode node
    def RequiredParameterNode: (name: Symbol, location: Location) -> RequiredParameterNode
    # Create a new RescueModifierNode node
    def RescueModifierNode: (expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location) -> RescueModifierNode
    # Create a new RescueNode node
    def RescueNode: (keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, reference: Node?, statements: StatementsNode?, consequent: RescueNode?, location: Location) -> RescueNode
    # Create a new RestParameterNode node
    def RestParameterNode: (name: Symbol?, name_loc: Location?, operator_loc: Location, location: Location) -> RestParameterNode
    # Create a new RetryNode node
    def RetryNode: (location: Location) -> RetryNode
    # Create a new ReturnNode node
    def ReturnNode: (keyword_loc: Location, arguments: ArgumentsNode?, location: Location) -> ReturnNode
    # Create a new SelfNode node
    def SelfNode: (location: Location) -> SelfNode
    # Create a new SingletonClassNode node
    def SingletonClassNode: (locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, body: Node?, end_keyword_loc: Location, location: Location) -> SingletonClassNode
    # Create a new SourceEncodingNode node
    def SourceEncodingNode: (location: Location) -> SourceEncodingNode
    # Create a new SourceFileNode node
    def SourceFileNode: (filepath: String, location: Location) -> SourceFileNode
    # Create a new SourceLineNode node
    def SourceLineNode: (location: Location) -> SourceLineNode
    # Create a new SplatNode node
    def SplatNode: (operator_loc: Location, expression: Node?, location: Location) -> SplatNode
    # Create a new StatementsNode node
    def StatementsNode: (body: Array[Node], location: Location) -> StatementsNode
    # Create a new StringConcatNode node
    def StringConcatNode: (left: Node, right: Node, location: Location) -> StringConcatNode
    # Create a new StringNode node
    def StringNode: (flags: Integer, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> StringNode
    # Create a new SuperNode node
    def SuperNode: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: Node?, location: Location) -> SuperNode
    # Create a new SymbolNode node
    def SymbolNode: (opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String, location: Location) -> SymbolNode
    # Create a new TrueNode node
    def TrueNode: (location: Location) -> TrueNode
    # Create a new UndefNode node
    def UndefNode: (names: Array[Node], keyword_loc: Location, location: Location) -> UndefNode
    # Create a new UnlessNode node
    def UnlessNode: (keyword_loc: Location, predicate: Node, statements: StatementsNode?, consequent: ElseNode?, end_keyword_loc: Location?, location: Location) -> UnlessNode
    # Create a new UntilNode node
    def UntilNode: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> UntilNode
    # Create a new WhenNode node
    def WhenNode: (keyword_loc: Location, conditions: Array[Node], statements: StatementsNode?, location: Location) -> WhenNode
    # Create a new WhileNode node
    def WhileNode: (keyword_loc: Location, closing_loc: Location?, predicate: Node, statements: StatementsNode?, flags: Integer, location: Location) -> WhileNode
    # Create a new XStringNode node
    def XStringNode: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location) -> XStringNode
    # Create a new YieldNode node
    def YieldNode: (keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, location: Location) -> YieldNode
  end
end

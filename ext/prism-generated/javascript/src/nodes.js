/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/javascript/src/nodes.js.erb                                      */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/

/**
 * Flags for arguments nodes.
 */
const ArgumentsNodeFlags = {
  KEYWORD_SPLAT: 1 << 0,
};

/**
 * Flags for call nodes.
 */
const CallNodeFlags = {
  SAFE_NAVIGATION: 1 << 0,
  VARIABLE_CALL: 1 << 1,
};

/**
 * Flags for integer nodes that correspond to the base of the integer.
 */
const IntegerBaseFlags = {
  BINARY: 1 << 0,
  OCTAL: 1 << 1,
  DECIMAL: 1 << 2,
  HEXADECIMAL: 1 << 3,
};

/**
 * Flags for while and until loop nodes.
 */
const LoopFlags = {
  BEGIN_MODIFIER: 1 << 0,
};

/**
 * Flags for range and flip-flop nodes.
 */
const RangeFlags = {
  EXCLUDE_END: 1 << 0,
};

/**
 * Flags for regular expression and match last line nodes.
 */
const RegularExpressionFlags = {
  IGNORE_CASE: 1 << 0,
  EXTENDED: 1 << 1,
  MULTI_LINE: 1 << 2,
  ONCE: 1 << 3,
  EUC_JP: 1 << 4,
  ASCII_8BIT: 1 << 5,
  WINDOWS_31J: 1 << 6,
  UTF_8: 1 << 7,
};

/**
 * Flags for string nodes.
 */
const StringFlags = {
  FROZEN: 1 << 0,
};

/**
 * A location in the source code.
 *
 * @typedef {{ startOffset: number, length: number }} Location
 */

/**
 * A generic node in the tree.
 *
 * @typedef {(AliasGlobalVariableNode|AliasMethodNode|AlternationPatternNode|AndNode|ArgumentsNode|ArrayNode|ArrayPatternNode|AssocNode|AssocSplatNode|BackReferenceReadNode|BeginNode|BlockArgumentNode|BlockLocalVariableNode|BlockNode|BlockParameterNode|BlockParametersNode|BreakNode|CallAndWriteNode|CallNode|CallOperatorWriteNode|CallOrWriteNode|CapturePatternNode|CaseNode|ClassNode|ClassVariableAndWriteNode|ClassVariableOperatorWriteNode|ClassVariableOrWriteNode|ClassVariableReadNode|ClassVariableTargetNode|ClassVariableWriteNode|ConstantAndWriteNode|ConstantOperatorWriteNode|ConstantOrWriteNode|ConstantPathAndWriteNode|ConstantPathNode|ConstantPathOperatorWriteNode|ConstantPathOrWriteNode|ConstantPathTargetNode|ConstantPathWriteNode|ConstantReadNode|ConstantTargetNode|ConstantWriteNode|DefNode|DefinedNode|ElseNode|EmbeddedStatementsNode|EmbeddedVariableNode|EnsureNode|FalseNode|FindPatternNode|FlipFlopNode|FloatNode|ForNode|ForwardingArgumentsNode|ForwardingParameterNode|ForwardingSuperNode|GlobalVariableAndWriteNode|GlobalVariableOperatorWriteNode|GlobalVariableOrWriteNode|GlobalVariableReadNode|GlobalVariableTargetNode|GlobalVariableWriteNode|HashNode|HashPatternNode|IfNode|ImaginaryNode|ImplicitNode|InNode|IndexAndWriteNode|IndexOperatorWriteNode|IndexOrWriteNode|InstanceVariableAndWriteNode|InstanceVariableOperatorWriteNode|InstanceVariableOrWriteNode|InstanceVariableReadNode|InstanceVariableTargetNode|InstanceVariableWriteNode|IntegerNode|InterpolatedMatchLastLineNode|InterpolatedRegularExpressionNode|InterpolatedStringNode|InterpolatedSymbolNode|InterpolatedXStringNode|KeywordHashNode|KeywordRestParameterNode|LambdaNode|LocalVariableAndWriteNode|LocalVariableOperatorWriteNode|LocalVariableOrWriteNode|LocalVariableReadNode|LocalVariableTargetNode|LocalVariableWriteNode|MatchLastLineNode|MatchPredicateNode|MatchRequiredNode|MatchWriteNode|MissingNode|ModuleNode|MultiTargetNode|MultiWriteNode|NextNode|NilNode|NoKeywordsParameterNode|NumberedReferenceReadNode|OptionalKeywordParameterNode|OptionalParameterNode|OrNode|ParametersNode|ParenthesesNode|PinnedExpressionNode|PinnedVariableNode|PostExecutionNode|PreExecutionNode|ProgramNode|RangeNode|RationalNode|RedoNode|RegularExpressionNode|RequiredKeywordParameterNode|RequiredParameterNode|RescueModifierNode|RescueNode|RestParameterNode|RetryNode|ReturnNode|SelfNode|SingletonClassNode|SourceEncodingNode|SourceFileNode|SourceLineNode|SplatNode|StatementsNode|StringConcatNode|StringNode|SuperNode|SymbolNode|TrueNode|UndefNode|UnlessNode|UntilNode|WhenNode|WhileNode|XStringNode|YieldNode)} Node
 */

/**
 * Represents the use of the `alias` keyword to alias a global variable.
 *
 *     alias $foo $bar
 *     ^^^^^^^^^^^^^^^
 */
export class AliasGlobalVariableNode {
  /**
   * @type Node
   */
  newName;

  /**
   * @type Node
   */
  oldName;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AliasGlobalVariableNode.
   *
   * @param {Node} newName
   * @param {Node} oldName
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(newName, oldName, keywordLoc, location) {
    this.newName = newName;
    this.oldName = oldName;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AliasGlobalVariableNode",
      newName: this.newName,
      oldName: this.oldName,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `alias` keyword to alias a method.
 *
 *     alias foo bar
 *     ^^^^^^^^^^^^^
 */
export class AliasMethodNode {
  /**
   * @type Node
   */
  newName;

  /**
   * @type Node
   */
  oldName;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AliasMethodNode.
   *
   * @param {Node} newName
   * @param {Node} oldName
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(newName, oldName, keywordLoc, location) {
    this.newName = newName;
    this.oldName = oldName;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AliasMethodNode",
      newName: this.newName,
      oldName: this.oldName,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents an alternation pattern in pattern matching.
 *
 *     foo => bar | baz
 *            ^^^^^^^^^
 */
export class AlternationPatternNode {
  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AlternationPatternNode.
   *
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(left, right, operatorLoc, location) {
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AlternationPatternNode",
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&` operator or the `and` keyword.
 *
 *     left and right
 *     ^^^^^^^^^^^^^^
 */
export class AndNode {
  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AndNode.
   *
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(left, right, operatorLoc, location) {
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AndNode",
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a set of arguments to a method or a keyword.
 *
 *     return foo, bar, baz
 *            ^^^^^^^^^^^^^
 */
export class ArgumentsNode {
  /**
   * @type Node[]
   */
  arguments_;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ArgumentsNode.
   *
   * @param {Node[]} arguments_
   * @param {number} flags
   * @param {Location} location
   */
  constructor(arguments_, flags, location) {
    this.arguments_ = arguments_;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the KEYWORD_SPLAT flag.
   *
   * @returns {boolean}
   */
  isKeywordSplat() {
    return (this.#flags & ArgumentsNodeFlags.KEYWORD_SPLAT) !== 0;
  }

  toJSON() {
    return {
      type: "ArgumentsNode",
      arguments: this.arguments_,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents an array literal. This can be a regular array using brackets or
 * a special array using % like %w or %i.
 *
 *     [1, 2, 3]
 *     ^^^^^^^^^
 */
export class ArrayNode {
  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ArrayNode.
   *
   * @param {Node[]} elements
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(elements, openingLoc, closingLoc, location) {
    this.elements = elements;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ArrayNode",
      elements: this.elements,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents an array pattern in pattern matching.
 *
 *     foo in 1, 2
 *     ^^^^^^^^^^^
 *
 *     foo in [1, 2]
 *     ^^^^^^^^^^^^^
 *
 *     foo in *1
 *     ^^^^^^^^^
 *
 *     foo in Bar[]
 *     ^^^^^^^^^^^^
 *
 *     foo in Bar[1, 2, 3]
 *     ^^^^^^^^^^^^^^^^^^^
 */
export class ArrayPatternNode {
  /**
   * @type Node | null
   */
  constant;

  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  posts;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ArrayPatternNode.
   *
   * @param {Node | null} constant
   * @param {Node[]} requireds
   * @param {Node | null} rest
   * @param {Node[]} posts
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(constant, requireds, rest, posts, openingLoc, closingLoc, location) {
    this.constant = constant;
    this.requireds = requireds;
    this.rest = rest;
    this.posts = posts;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ArrayPatternNode",
      constant: this.constant,
      requireds: this.requireds,
      rest: this.rest,
      posts: this.posts,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents a hash key/value pair.
 *
 *     { a => b }
 *       ^^^^^^
 */
export class AssocNode {
  /**
   * @type Node
   */
  key;

  /**
   * @type Node | null
   */
  value;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AssocNode.
   *
   * @param {Node} key
   * @param {Node | null} value
   * @param {Location | null} operatorLoc
   * @param {Location} location
   */
  constructor(key, value, operatorLoc, location) {
    this.key = key;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AssocNode",
      key: this.key,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a splat in a hash literal.
 *
 *     { **foo }
 *       ^^^^^
 */
export class AssocSplatNode {
  /**
   * @type Node | null
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new AssocSplatNode.
   *
   * @param {Node | null} value
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(value, operatorLoc, location) {
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "AssocSplatNode",
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents reading a reference to a field in the previous match.
 *
 *     $'
 *     ^^
 */
export class BackReferenceReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BackReferenceReadNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BackReferenceReadNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents a begin statement.
 *
 *     begin
 *       foo
 *     end
 *     ^^^^^
 */
export class BeginNode {
  /**
   * @type Location | null
   */
  beginKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type RescueNode | null
   */
  rescueClause;

  /**
   * @type ElseNode | null
   */
  elseClause;

  /**
   * @type EnsureNode | null
   */
  ensureClause;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BeginNode.
   *
   * @param {Location | null} beginKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {RescueNode | null} rescueClause
   * @param {ElseNode | null} elseClause
   * @param {EnsureNode | null} ensureClause
   * @param {Location | null} endKeywordLoc
   * @param {Location} location
   */
  constructor(beginKeywordLoc, statements, rescueClause, elseClause, ensureClause, endKeywordLoc, location) {
    this.beginKeywordLoc = beginKeywordLoc;
    this.statements = statements;
    this.rescueClause = rescueClause;
    this.elseClause = elseClause;
    this.ensureClause = ensureClause;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BeginNode",
      beginKeywordLoc: this.beginKeywordLoc,
      statements: this.statements,
      rescueClause: this.rescueClause,
      elseClause: this.elseClause,
      ensureClause: this.ensureClause,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents block method arguments.
 *
 *     bar(&args)
 *     ^^^^^^^^^^
 */
export class BlockArgumentNode {
  /**
   * @type Node | null
   */
  expression;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BlockArgumentNode.
   *
   * @param {Node | null} expression
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(expression, operatorLoc, location) {
    this.expression = expression;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BlockArgumentNode",
      expression: this.expression,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a block local variable.
 *
 *     a { |; b| }
 *            ^
 */
export class BlockLocalVariableNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BlockLocalVariableNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BlockLocalVariableNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents a block of ruby code.
 *
 * [1, 2, 3].each { |i| puts x }
 *                ^^^^^^^^^^^^^^
 */
export class BlockNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type BlockParametersNode | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BlockNode.
   *
   * @param {string[]} locals
   * @param {BlockParametersNode | null} parameters
   * @param {Node | null} body
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(locals, parameters, body, openingLoc, closingLoc, location) {
    this.locals = locals;
    this.parameters = parameters;
    this.body = body;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BlockNode",
      locals: this.locals,
      parameters: this.parameters,
      body: this.body,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents a block parameter to a method, block, or lambda definition.
 *
 *     def a(&b)
 *           ^^
 *     end
 */
export class BlockParameterNode {
  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BlockParameterNode.
   *
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BlockParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a block's parameters declaration.
 *
 *     -> (a, b = 1; local) { }
 *        ^^^^^^^^^^^^^^^^^
 *
 *     foo do |a, b = 1; local|
 *            ^^^^^^^^^^^^^^^^^
 *     end
 */
export class BlockParametersNode {
  /**
   * @type ParametersNode | null
   */
  parameters;

  /**
   * @type Node[]
   */
  locals;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BlockParametersNode.
   *
   * @param {ParametersNode | null} parameters
   * @param {Node[]} locals
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(parameters, locals, openingLoc, closingLoc, location) {
    this.parameters = parameters;
    this.locals = locals;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BlockParametersNode",
      parameters: this.parameters,
      locals: this.locals,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `break` keyword.
 *
 *     break foo
 *     ^^^^^^^^^
 */
export class BreakNode {
  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new BreakNode.
   *
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(arguments_, keywordLoc, location) {
    this.arguments_ = arguments_;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "BreakNode",
      arguments: this.arguments_,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator on a call.
 *
 *     foo.bar &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallAndWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CallAndWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {number} flags
   * @param {string} readName
   * @param {string} writeName
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, messageLoc, flags, readName, writeName, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.#flags = flags;
    this.readName = readName;
    this.writeName = writeName;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "CallAndWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      flags: this.#flags,
      readName: this.readName,
      writeName: this.writeName,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents a method call, in all of the various forms that can take.
 *
 *     foo
 *     ^^^
 *
 *     foo()
 *     ^^^^^
 *
 *     +foo
 *     ^^^^
 *
 *     foo + bar
 *     ^^^^^^^^^
 *
 *     foo.bar
 *     ^^^^^^^
 *
 *     foo&.bar
 *     ^^^^^^^^
 */
export class CallNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CallNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {Location | null} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} closingLoc
   * @param {Node | null} block
   * @param {number} flags
   * @param {string} name
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, messageLoc, openingLoc, arguments_, closingLoc, block, flags, name, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.#flags = flags;
    this.name = name;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "CallNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      flags: this.#flags,
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents the use of an assignment operator on a call.
 *
 *     foo.bar += baz
 *     ^^^^^^^^^^^^^^
 */
export class CallOperatorWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type string
   */
  operator;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CallOperatorWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {number} flags
   * @param {string} readName
   * @param {string} writeName
   * @param {string} operator
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, messageLoc, flags, readName, writeName, operator, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.#flags = flags;
    this.readName = readName;
    this.writeName = writeName;
    this.operator = operator;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "CallOperatorWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      flags: this.#flags,
      readName: this.readName,
      writeName: this.writeName,
      operator: this.operator,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator on a call.
 *
 *     foo.bar ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallOrWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CallOrWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {number} flags
   * @param {string} readName
   * @param {string} writeName
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, messageLoc, flags, readName, writeName, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.#flags = flags;
    this.readName = readName;
    this.writeName = writeName;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "CallOrWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      flags: this.#flags,
      readName: this.readName,
      writeName: this.writeName,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a local variable in pattern matching.
 *
 *     foo => [bar => baz]
 *            ^^^^^^^^^^^^
 */
export class CapturePatternNode {
  /**
   * @type Node
   */
  value;

  /**
   * @type Node
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CapturePatternNode.
   *
   * @param {Node} value
   * @param {Node} target
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(value, target, operatorLoc, location) {
    this.value = value;
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "CapturePatternNode",
      value: this.value,
      target: this.target,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of a case statement.
 *
 *     case true
 *     when false
 *     end
 *     ^^^^^^^^^^
 */
export class CaseNode {
  /**
   * @type Node | null
   */
  predicate;

  /**
   * @type Node[]
   */
  conditions;

  /**
   * @type ElseNode | null
   */
  consequent;

  /**
   * @type Location
   */
  caseKeywordLoc;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new CaseNode.
   *
   * @param {Node | null} predicate
   * @param {Node[]} conditions
   * @param {ElseNode | null} consequent
   * @param {Location} caseKeywordLoc
   * @param {Location} endKeywordLoc
   * @param {Location} location
   */
  constructor(predicate, conditions, consequent, caseKeywordLoc, endKeywordLoc, location) {
    this.predicate = predicate;
    this.conditions = conditions;
    this.consequent = consequent;
    this.caseKeywordLoc = caseKeywordLoc;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "CaseNode",
      predicate: this.predicate,
      conditions: this.conditions,
      consequent: this.consequent,
      caseKeywordLoc: this.caseKeywordLoc,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents a class declaration involving the `class` keyword.
 *
 *     class Foo end
 *     ^^^^^^^^^^^^^
 */
export class ClassNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  classKeywordLoc;

  /**
   * @type Node
   */
  constantPath;

  /**
   * @type Location | null
   */
  inheritanceOperatorLoc;

  /**
   * @type Node | null
   */
  superclass;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassNode.
   *
   * @param {string[]} locals
   * @param {Location} classKeywordLoc
   * @param {Node} constantPath
   * @param {Location | null} inheritanceOperatorLoc
   * @param {Node | null} superclass
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   * @param {string} name
   * @param {Location} location
   */
  constructor(locals, classKeywordLoc, constantPath, inheritanceOperatorLoc, superclass, body, endKeywordLoc, name, location) {
    this.locals = locals;
    this.classKeywordLoc = classKeywordLoc;
    this.constantPath = constantPath;
    this.inheritanceOperatorLoc = inheritanceOperatorLoc;
    this.superclass = superclass;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassNode",
      locals: this.locals,
      classKeywordLoc: this.classKeywordLoc,
      constantPath: this.constantPath,
      inheritanceOperatorLoc: this.inheritanceOperatorLoc,
      superclass: this.superclass,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a class variable.
 *
 *     @@target &&= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableAndWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableAndWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableAndWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a class variable using an operator that isn't `=`.
 *
 *     @@target += value
 *     ^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOperatorWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  operator;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableOperatorWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} operator
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, operator, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.operator = operator;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableOperatorWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      operator: this.operator,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a class variable.
 *
 *     @@target ||= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOrWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableOrWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableOrWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents referencing a class variable.
 *
 *     @@foo
 *     ^^^^^
 */
export class ClassVariableReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableReadNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableReadNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a class variable in a context that doesn't have an explicit value.
 *
 *     @@foo, @@bar = baz
 *     ^^^^^  ^^^^^
 */
export class ClassVariableTargetNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableTargetNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableTargetNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a class variable.
 *
 *     @@foo = 1
 *     ^^^^^^^^^
 */
export class ClassVariableWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ClassVariableWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location | null} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, value, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ClassVariableWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a constant.
 *
 *     Target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantAndWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantAndWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantAndWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a constant using an operator that isn't `=`.
 *
 *     Target += value
 *     ^^^^^^^^^^^^^^^
 */
export class ConstantOperatorWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  operator;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantOperatorWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} operator
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, operator, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.operator = operator;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantOperatorWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      operator: this.operator,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a constant.
 *
 *     Target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantOrWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantOrWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantOrWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a constant path.
 *
 *     Parent::Child &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathAndWriteNode {
  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathAndWriteNode.
   *
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(target, operatorLoc, value, location) {
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathAndWriteNode",
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents accessing a constant through a path of `::` operators.
 *
 *     Foo::Bar
 *     ^^^^^^^^
 */
export class ConstantPathNode {
  /**
   * @type Node | null
   */
  parent;

  /**
   * @type Node
   */
  child;

  /**
   * @type Location
   */
  delimiterLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathNode.
   *
   * @param {Node | null} parent
   * @param {Node} child
   * @param {Location} delimiterLoc
   * @param {Location} location
   */
  constructor(parent, child, delimiterLoc, location) {
    this.parent = parent;
    this.child = child;
    this.delimiterLoc = delimiterLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathNode",
      parent: this.parent,
      child: this.child,
      delimiterLoc: this.delimiterLoc,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a constant path using an operator that isn't `=`.
 *
 *     Parent::Child += value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOperatorWriteNode {
  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  operator;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathOperatorWriteNode.
   *
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} operator
   * @param {Location} location
   */
  constructor(target, operatorLoc, value, operator, location) {
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.operator = operator;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathOperatorWriteNode",
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
      operator: this.operator,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a constant path.
 *
 *     Parent::Child ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOrWriteNode {
  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathOrWriteNode.
   *
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(target, operatorLoc, value, location) {
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathOrWriteNode",
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents writing to a constant path in a context that doesn't have an explicit value.
 *
 *     Foo::Foo, Bar::Bar = baz
 *     ^^^^^^^^  ^^^^^^^^
 */
export class ConstantPathTargetNode {
  /**
   * @type Node | null
   */
  parent;

  /**
   * @type Node
   */
  child;

  /**
   * @type Location
   */
  delimiterLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathTargetNode.
   *
   * @param {Node | null} parent
   * @param {Node} child
   * @param {Location} delimiterLoc
   * @param {Location} location
   */
  constructor(parent, child, delimiterLoc, location) {
    this.parent = parent;
    this.child = child;
    this.delimiterLoc = delimiterLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathTargetNode",
      parent: this.parent,
      child: this.child,
      delimiterLoc: this.delimiterLoc,
      location: this.location
    };
  }
}

/**
 * Represents writing to a constant path.
 *
 *     ::Foo = 1
 *     ^^^^^^^^^
 *
 *     Foo::Bar = 1
 *     ^^^^^^^^^^^^
 *
 *     ::Foo::Bar = 1
 *     ^^^^^^^^^^^^^^
 */
export class ConstantPathWriteNode {
  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantPathWriteNode.
   *
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(target, operatorLoc, value, location) {
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantPathWriteNode",
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents referencing a constant.
 *
 *     Foo
 *     ^^^
 */
export class ConstantReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantReadNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantReadNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a constant in a context that doesn't have an explicit value.
 *
 *     Foo, Bar = baz
 *     ^^^  ^^^
 */
export class ConstantTargetNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantTargetNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantTargetNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a constant.
 *
 *     Foo = 1
 *     ^^^^^^^
 */
export class ConstantWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ConstantWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, value, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ConstantWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a method definition.
 *
 *     def method
 *     end
 *     ^^^^^^^^^^
 */
export class DefNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type ParametersNode | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  defKeywordLoc;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location | null
   */
  equalLoc;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new DefNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node | null} receiver
   * @param {ParametersNode | null} parameters
   * @param {Node | null} body
   * @param {string[]} locals
   * @param {Location} defKeywordLoc
   * @param {Location | null} operatorLoc
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   * @param {Location | null} equalLoc
   * @param {Location | null} endKeywordLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, receiver, parameters, body, locals, defKeywordLoc, operatorLoc, lparenLoc, rparenLoc, equalLoc, endKeywordLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.receiver = receiver;
    this.parameters = parameters;
    this.body = body;
    this.locals = locals;
    this.defKeywordLoc = defKeywordLoc;
    this.operatorLoc = operatorLoc;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.equalLoc = equalLoc;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "DefNode",
      name: this.name,
      nameLoc: this.nameLoc,
      receiver: this.receiver,
      parameters: this.parameters,
      body: this.body,
      locals: this.locals,
      defKeywordLoc: this.defKeywordLoc,
      operatorLoc: this.operatorLoc,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      equalLoc: this.equalLoc,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `defined?` keyword.
 *
 *     defined?(a)
 *     ^^^^^^^^^^^
 */
export class DefinedNode {
  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new DefinedNode.
   *
   * @param {Location | null} lparenLoc
   * @param {Node} value
   * @param {Location | null} rparenLoc
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(lparenLoc, value, rparenLoc, keywordLoc, location) {
    this.lparenLoc = lparenLoc;
    this.value = value;
    this.rparenLoc = rparenLoc;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "DefinedNode",
      lparenLoc: this.lparenLoc,
      value: this.value,
      rparenLoc: this.rparenLoc,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents an `else` clause in a `case`, `if`, or `unless` statement.
 *
 *     if a then b else c end
 *                 ^^^^^^^^^^
 */
export class ElseNode {
  /**
   * @type Location
   */
  elseKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ElseNode.
   *
   * @param {Location} elseKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {Location | null} endKeywordLoc
   * @param {Location} location
   */
  constructor(elseKeywordLoc, statements, endKeywordLoc, location) {
    this.elseKeywordLoc = elseKeywordLoc;
    this.statements = statements;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ElseNode",
      elseKeywordLoc: this.elseKeywordLoc,
      statements: this.statements,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents an interpolated set of statements.
 *
 *     "foo #{bar}"
 *          ^^^^^^
 */
export class EmbeddedStatementsNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new EmbeddedStatementsNode.
   *
   * @param {Location} openingLoc
   * @param {StatementsNode | null} statements
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(openingLoc, statements, closingLoc, location) {
    this.openingLoc = openingLoc;
    this.statements = statements;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "EmbeddedStatementsNode",
      openingLoc: this.openingLoc,
      statements: this.statements,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents an interpolated variable.
 *
 *     "foo #@bar"
 *          ^^^^^
 */
export class EmbeddedVariableNode {
  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  variable;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new EmbeddedVariableNode.
   *
   * @param {Location} operatorLoc
   * @param {Node} variable
   * @param {Location} location
   */
  constructor(operatorLoc, variable, location) {
    this.operatorLoc = operatorLoc;
    this.variable = variable;
    this.location = location;
  }

  toJSON() {
    return {
      type: "EmbeddedVariableNode",
      operatorLoc: this.operatorLoc,
      variable: this.variable,
      location: this.location
    };
  }
}

/**
 * Represents an `ensure` clause in a `begin` statement.
 *
 *     begin
 *       foo
 *     ensure
 *     ^^^^^^
 *       bar
 *     end
 */
export class EnsureNode {
  /**
   * @type Location
   */
  ensureKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new EnsureNode.
   *
   * @param {Location} ensureKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {Location} endKeywordLoc
   * @param {Location} location
   */
  constructor(ensureKeywordLoc, statements, endKeywordLoc, location) {
    this.ensureKeywordLoc = ensureKeywordLoc;
    this.statements = statements;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "EnsureNode",
      ensureKeywordLoc: this.ensureKeywordLoc,
      statements: this.statements,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the literal `false` keyword.
 *
 *     false
 *     ^^^^^
 */
export class FalseNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new FalseNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "FalseNode",
      location: this.location
    };
  }
}

/**
 * Represents a find pattern in pattern matching.
 *
 *     foo in *bar, baz, *qux
 *            ^^^^^^^^^^^^^^^
 *
 *     foo in [*bar, baz, *qux]
 *            ^^^^^^^^^^^^^^^^^
 *
 *     foo in Foo(*bar, baz, *qux)
 *            ^^^^^^^^^^^^^^^^^^^^
 */
export class FindPatternNode {
  /**
   * @type Node | null
   */
  constant;

  /**
   * @type Node
   */
  left;

  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new FindPatternNode.
   *
   * @param {Node | null} constant
   * @param {Node} left
   * @param {Node[]} requireds
   * @param {Node} right
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(constant, left, requireds, right, openingLoc, closingLoc, location) {
    this.constant = constant;
    this.left = left;
    this.requireds = requireds;
    this.right = right;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "FindPatternNode",
      constant: this.constant,
      left: this.left,
      requireds: this.requireds,
      right: this.right,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `..` or `...` operators to create flip flops.
 *
 *     baz if foo .. bar
 *            ^^^^^^^^^^
 */
export class FlipFlopNode {
  /**
   * @type Node | null
   */
  left;

  /**
   * @type Node | null
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new FlipFlopNode.
   *
   * @param {Node | null} left
   * @param {Node | null} right
   * @param {Location} operatorLoc
   * @param {number} flags
   * @param {Location} location
   */
  constructor(left, right, operatorLoc, flags, location) {
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the EXCLUDE_END flag.
   *
   * @returns {boolean}
   */
  isExcludeEnd() {
    return (this.#flags & RangeFlags.EXCLUDE_END) !== 0;
  }

  toJSON() {
    return {
      type: "FlipFlopNode",
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a floating point number literal.
 *
 *     1.0
 *     ^^^
 */
export class FloatNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new FloatNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "FloatNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the `for` keyword.
 *
 *     for i in a end
 *     ^^^^^^^^^^^^^^
 */
export class ForNode {
  /**
   * @type Node
   */
  index;

  /**
   * @type Node
   */
  collection;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  forKeywordLoc;

  /**
   * @type Location
   */
  inKeywordLoc;

  /**
   * @type Location | null
   */
  doKeywordLoc;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ForNode.
   *
   * @param {Node} index
   * @param {Node} collection
   * @param {StatementsNode | null} statements
   * @param {Location} forKeywordLoc
   * @param {Location} inKeywordLoc
   * @param {Location | null} doKeywordLoc
   * @param {Location} endKeywordLoc
   * @param {Location} location
   */
  constructor(index, collection, statements, forKeywordLoc, inKeywordLoc, doKeywordLoc, endKeywordLoc, location) {
    this.index = index;
    this.collection = collection;
    this.statements = statements;
    this.forKeywordLoc = forKeywordLoc;
    this.inKeywordLoc = inKeywordLoc;
    this.doKeywordLoc = doKeywordLoc;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ForNode",
      index: this.index,
      collection: this.collection,
      statements: this.statements,
      forKeywordLoc: this.forKeywordLoc,
      inKeywordLoc: this.inKeywordLoc,
      doKeywordLoc: this.doKeywordLoc,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents forwarding all arguments to this method to another method.
 *
 *     def foo(...)
 *       bar(...)
 *           ^^^
 *     end
 */
export class ForwardingArgumentsNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ForwardingArgumentsNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "ForwardingArgumentsNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the forwarding parameter in a method, block, or lambda declaration.
 *
 *     def foo(...)
 *             ^^^
 *     end
 */
export class ForwardingParameterNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ForwardingParameterNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "ForwardingParameterNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the `super` keyword without parentheses or arguments.
 *
 *     super
 *     ^^^^^
 */
export class ForwardingSuperNode {
  /**
   * @type BlockNode | null
   */
  block;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ForwardingSuperNode.
   *
   * @param {BlockNode | null} block
   * @param {Location} location
   */
  constructor(block, location) {
    this.block = block;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ForwardingSuperNode",
      block: this.block,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a global variable.
 *
 *     $target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableAndWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableAndWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableAndWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a global variable using an operator that isn't `=`.
 *
 *     $target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOperatorWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  operator;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableOperatorWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} operator
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, operator, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.operator = operator;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableOperatorWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      operator: this.operator,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a global variable.
 *
 *     $target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOrWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableOrWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableOrWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents referencing a global variable.
 *
 *     $foo
 *     ^^^^
 */
export class GlobalVariableReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableReadNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableReadNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a global variable in a context that doesn't have an explicit value.
 *
 *     $foo, $bar = baz
 *     ^^^^  ^^^^
 */
export class GlobalVariableTargetNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableTargetNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableTargetNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to a global variable.
 *
 *     $foo = 1
 *     ^^^^^^^^
 */
export class GlobalVariableWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new GlobalVariableWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, value, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "GlobalVariableWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a hash literal.
 *
 *     { a => b }
 *     ^^^^^^^^^^
 */
export class HashNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new HashNode.
   *
   * @param {Location} openingLoc
   * @param {Node[]} elements
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(openingLoc, elements, closingLoc, location) {
    this.openingLoc = openingLoc;
    this.elements = elements;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "HashNode",
      openingLoc: this.openingLoc,
      elements: this.elements,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents a hash pattern in pattern matching.
 *
 *     foo => { a: 1, b: 2 }
 *            ^^^^^^^^^^^^^^
 *
 *     foo => { a: 1, b: 2, **c }
 *            ^^^^^^^^^^^^^^^^^^^
 */
export class HashPatternNode {
  /**
   * @type Node | null
   */
  constant;

  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new HashPatternNode.
   *
   * @param {Node | null} constant
   * @param {Node[]} elements
   * @param {Node | null} rest
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(constant, elements, rest, openingLoc, closingLoc, location) {
    this.constant = constant;
    this.elements = elements;
    this.rest = rest;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "HashPatternNode",
      constant: this.constant,
      elements: this.elements,
      rest: this.rest,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `if` keyword, either in the block form or the modifier form.
 *
 *     bar if foo
 *     ^^^^^^^^^^
 *
 *     if foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^
 */
export class IfNode {
  /**
   * @type Location | null
   */
  ifKeywordLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Node | null
   */
  consequent;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new IfNode.
   *
   * @param {Location | null} ifKeywordLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   * @param {Node | null} consequent
   * @param {Location | null} endKeywordLoc
   * @param {Location} location
   */
  constructor(ifKeywordLoc, predicate, statements, consequent, endKeywordLoc, location) {
    this.ifKeywordLoc = ifKeywordLoc;
    this.predicate = predicate;
    this.statements = statements;
    this.consequent = consequent;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "IfNode",
      ifKeywordLoc: this.ifKeywordLoc,
      predicate: this.predicate,
      statements: this.statements,
      consequent: this.consequent,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents an imaginary number literal.
 *
 *     1.0i
 *     ^^^^
 */
export class ImaginaryNode {
  /**
   * @type Node
   */
  numeric;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ImaginaryNode.
   *
   * @param {Node} numeric
   * @param {Location} location
   */
  constructor(numeric, location) {
    this.numeric = numeric;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ImaginaryNode",
      numeric: this.numeric,
      location: this.location
    };
  }
}

/**
 * Represents a node that is implicitly being added to the tree but doesn't
 * correspond directly to a node in the source.
 *
 *     { foo: }
 *       ^^^^
 *
 *     { Foo: }
 *       ^^^^
 */
export class ImplicitNode {
  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ImplicitNode.
   *
   * @param {Node} value
   * @param {Location} location
   */
  constructor(value, location) {
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ImplicitNode",
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `in` keyword in a case statement.
 *
 *     case a; in b then c end
 *             ^^^^^^^^^^^
 */
export class InNode {
  /**
   * @type Node
   */
  pattern;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  inLoc;

  /**
   * @type Location | null
   */
  thenLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InNode.
   *
   * @param {Node} pattern
   * @param {StatementsNode | null} statements
   * @param {Location} inLoc
   * @param {Location | null} thenLoc
   * @param {Location} location
   */
  constructor(pattern, statements, inLoc, thenLoc, location) {
    this.pattern = pattern;
    this.statements = statements;
    this.inLoc = inLoc;
    this.thenLoc = thenLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InNode",
      pattern: this.pattern,
      statements: this.statements,
      inLoc: this.inLoc,
      thenLoc: this.thenLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator on a call to the `[]` method.
 *
 *     foo.bar[baz] &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexAndWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new IndexAndWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {Node | null} block
   * @param {number} flags
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, flags, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.#flags = flags;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "IndexAndWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      flags: this.#flags,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of an assignment operator on a call to `[]`.
 *
 *     foo.bar[baz] += value
 *     ^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOperatorWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  operator;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new IndexOperatorWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {Node | null} block
   * @param {number} flags
   * @param {string} operator
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, flags, operator, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.#flags = flags;
    this.operator = operator;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "IndexOperatorWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      flags: this.#flags,
      operator: this.operator,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator on a call to `[]`.
 *
 *     foo.bar[baz] ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOrWriteNode {
  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new IndexOrWriteNode.
   *
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {Node | null} block
   * @param {number} flags
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, flags, operatorLoc, value, location) {
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.#flags = flags;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  toJSON() {
    return {
      type: "IndexOrWriteNode",
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      flags: this.#flags,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to an instance variable.
 *
 *     @target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableAndWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableAndWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableAndWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents assigning to an instance variable using an operator that isn't `=`.
 *
 *     @target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOperatorWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  operator;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableOperatorWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} operator
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, operator, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.operator = operator;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableOperatorWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      operator: this.operator,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to an instance variable.
 *
 *     @target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOrWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableOrWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableOrWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents referencing an instance variable.
 *
 *     @foo
 *     ^^^^
 */
export class InstanceVariableReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableReadNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableReadNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to an instance variable in a context that doesn't have an explicit value.
 *
 *     @foo, @bar = baz
 *     ^^^^  ^^^^
 */
export class InstanceVariableTargetNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableTargetNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableTargetNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents writing to an instance variable.
 *
 *     @foo = 1
 *     ^^^^^^^^
 */
export class InstanceVariableWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InstanceVariableWriteNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, value, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InstanceVariableWriteNode",
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents an integer number literal.
 *
 *     1
 *     ^
 */
export class IntegerNode {
  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new IntegerNode.
   *
   * @param {number} flags
   * @param {Location} location
   */
  constructor(flags, location) {
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the BINARY flag.
   *
   * @returns {boolean}
   */
  isBinary() {
    return (this.#flags & IntegerBaseFlags.BINARY) !== 0;
  }

  /**
   * True if this node has the OCTAL flag.
   *
   * @returns {boolean}
   */
  isOctal() {
    return (this.#flags & IntegerBaseFlags.OCTAL) !== 0;
  }

  /**
   * True if this node has the DECIMAL flag.
   *
   * @returns {boolean}
   */
  isDecimal() {
    return (this.#flags & IntegerBaseFlags.DECIMAL) !== 0;
  }

  /**
   * True if this node has the HEXADECIMAL flag.
   *
   * @returns {boolean}
   */
  isHexadecimal() {
    return (this.#flags & IntegerBaseFlags.HEXADECIMAL) !== 0;
  }

  toJSON() {
    return {
      type: "IntegerNode",
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a regular expression literal that contains interpolation that
 * is being used in the predicate of a conditional to implicitly match
 * against the last line read by an IO object.
 *
 *     if /foo #{bar} baz/ then end
 *        ^^^^^^^^^^^^^^^^
 */
export class InterpolatedMatchLastLineNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InterpolatedMatchLastLineNode.
   *
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   * @param {number} flags
   * @param {Location} location
   */
  constructor(openingLoc, parts, closingLoc, flags, location) {
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  toJSON() {
    return {
      type: "InterpolatedMatchLastLineNode",
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a regular expression literal that contains interpolation.
 *
 *     /foo #{bar} baz/
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedRegularExpressionNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InterpolatedRegularExpressionNode.
   *
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   * @param {number} flags
   * @param {Location} location
   */
  constructor(openingLoc, parts, closingLoc, flags, location) {
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  toJSON() {
    return {
      type: "InterpolatedRegularExpressionNode",
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a string literal that contains interpolation.
 *
 *     "foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedStringNode {
  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InterpolatedStringNode.
   *
   * @param {Location | null} openingLoc
   * @param {Node[]} parts
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(openingLoc, parts, closingLoc, location) {
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InterpolatedStringNode",
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents a symbol literal that contains interpolation.
 *
 *     :"foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^^
 */
export class InterpolatedSymbolNode {
  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InterpolatedSymbolNode.
   *
   * @param {Location | null} openingLoc
   * @param {Node[]} parts
   * @param {Location | null} closingLoc
   * @param {Location} location
   */
  constructor(openingLoc, parts, closingLoc, location) {
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InterpolatedSymbolNode",
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents an xstring literal that contains interpolation.
 *
 *     `foo #{bar} baz`
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedXStringNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new InterpolatedXStringNode.
   *
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(openingLoc, parts, closingLoc, location) {
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "InterpolatedXStringNode",
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents a hash literal without opening and closing braces.
 *
 *     foo(a: b)
 *         ^^^^
 */
export class KeywordHashNode {
  /**
   * @type Node[]
   */
  elements;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new KeywordHashNode.
   *
   * @param {Node[]} elements
   * @param {Location} location
   */
  constructor(elements, location) {
    this.elements = elements;
    this.location = location;
  }

  toJSON() {
    return {
      type: "KeywordHashNode",
      elements: this.elements,
      location: this.location
    };
  }
}

/**
 * Represents a keyword rest parameter to a method, block, or lambda definition.
 *
 *     def a(**b)
 *           ^^^
 *     end
 */
export class KeywordRestParameterNode {
  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new KeywordRestParameterNode.
   *
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "KeywordRestParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents using a lambda literal (not the lambda method call).
 *
 *     ->(value) { value * 2 }
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class LambdaNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type BlockParametersNode | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LambdaNode.
   *
   * @param {string[]} locals
   * @param {Location} operatorLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {BlockParametersNode | null} parameters
   * @param {Node | null} body
   * @param {Location} location
   */
  constructor(locals, operatorLoc, openingLoc, closingLoc, parameters, body, location) {
    this.locals = locals;
    this.operatorLoc = operatorLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.parameters = parameters;
    this.body = body;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LambdaNode",
      locals: this.locals,
      operatorLoc: this.operatorLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      parameters: this.parameters,
      body: this.body,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a local variable.
 *
 *     target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableAndWriteNode {
  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableAndWriteNode.
   *
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {number} depth
   * @param {Location} location
   */
  constructor(nameLoc, operatorLoc, value, name, depth, location) {
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.name = name;
    this.depth = depth;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableAndWriteNode",
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      name: this.name,
      depth: this.depth,
      location: this.location
    };
  }
}

/**
 * Represents assigning to a local variable using an operator that isn't `=`.
 *
 *     target += value
 *     ^^^^^^^^^^^^^^^
 */
export class LocalVariableOperatorWriteNode {
  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type string
   */
  operator;

  /**
   * @type number
   */
  depth;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableOperatorWriteNode.
   *
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {string} operator
   * @param {number} depth
   * @param {Location} location
   */
  constructor(nameLoc, operatorLoc, value, name, operator, depth, location) {
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.name = name;
    this.operator = operator;
    this.depth = depth;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableOperatorWriteNode",
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      name: this.name,
      operator: this.operator,
      depth: this.depth,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a local variable.
 *
 *     target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableOrWriteNode {
  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableOrWriteNode.
   *
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {number} depth
   * @param {Location} location
   */
  constructor(nameLoc, operatorLoc, value, name, depth, location) {
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.name = name;
    this.depth = depth;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableOrWriteNode",
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      name: this.name,
      depth: this.depth,
      location: this.location
    };
  }
}

/**
 * Represents reading a local variable. Note that this requires that a local
 * variable of the same name has already been written to in the same scope,
 * otherwise it is parsed as a method call.
 *
 *     foo
 *     ^^^
 */
export class LocalVariableReadNode {
  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableReadNode.
   *
   * @param {string} name
   * @param {number} depth
   * @param {Location} location
   */
  constructor(name, depth, location) {
    this.name = name;
    this.depth = depth;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableReadNode",
      name: this.name,
      depth: this.depth,
      location: this.location
    };
  }
}

/**
 * Represents writing to a local variable in a context that doesn't have an explicit value.
 *
 *     foo, bar = baz
 *     ^^^  ^^^
 */
export class LocalVariableTargetNode {
  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableTargetNode.
   *
   * @param {string} name
   * @param {number} depth
   * @param {Location} location
   */
  constructor(name, depth, location) {
    this.name = name;
    this.depth = depth;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableTargetNode",
      name: this.name,
      depth: this.depth,
      location: this.location
    };
  }
}

/**
 * Represents writing to a local variable.
 *
 *     foo = 1
 *     ^^^^^^^
 */
export class LocalVariableWriteNode {
  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new LocalVariableWriteNode.
   *
   * @param {string} name
   * @param {number} depth
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, depth, nameLoc, value, operatorLoc, location) {
    this.name = name;
    this.depth = depth;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "LocalVariableWriteNode",
      name: this.name,
      depth: this.depth,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents a regular expression literal used in the predicate of a
 * conditional to implicitly match against the last line read by an IO
 * object.
 *
 *     if /foo/i then end
 *        ^^^^^^
 */
export class MatchLastLineNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type string
   */
  unescaped;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MatchLastLineNode.
   *
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {string} unescaped
   * @param {number} flags
   * @param {Location} location
   */
  constructor(openingLoc, contentLoc, closingLoc, unescaped, flags, location) {
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  toJSON() {
    return {
      type: "MatchLastLineNode",
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents the use of the modifier `in` operator.
 *
 *     foo in bar
 *     ^^^^^^^^^^
 */
export class MatchPredicateNode {
  /**
   * @type Node
   */
  value;

  /**
   * @type Node
   */
  pattern;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MatchPredicateNode.
   *
   * @param {Node} value
   * @param {Node} pattern
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(value, pattern, operatorLoc, location) {
    this.value = value;
    this.pattern = pattern;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "MatchPredicateNode",
      value: this.value,
      pattern: this.pattern,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `=>` operator.
 *
 *     foo => bar
 *     ^^^^^^^^^^
 */
export class MatchRequiredNode {
  /**
   * @type Node
   */
  value;

  /**
   * @type Node
   */
  pattern;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MatchRequiredNode.
   *
   * @param {Node} value
   * @param {Node} pattern
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(value, pattern, operatorLoc, location) {
    this.value = value;
    this.pattern = pattern;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "MatchRequiredNode",
      value: this.value,
      pattern: this.pattern,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents writing local variables using a regular expression match with
 * named capture groups.
 *
 *     /(?<foo>bar)/ =~ baz
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class MatchWriteNode {
  /**
   * @type CallNode
   */
  call;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MatchWriteNode.
   *
   * @param {CallNode} call
   * @param {string[]} locals
   * @param {Location} location
   */
  constructor(call, locals, location) {
    this.call = call;
    this.locals = locals;
    this.location = location;
  }

  toJSON() {
    return {
      type: "MatchWriteNode",
      call: this.call,
      locals: this.locals,
      location: this.location
    };
  }
}

/**
 * Represents a node that is missing from the source and results in a syntax
 * error.
 */
export class MissingNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MissingNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "MissingNode",
      location: this.location
    };
  }
}

/**
 * Represents a module declaration involving the `module` keyword.
 *
 *     module Foo end
 *     ^^^^^^^^^^^^^^
 */
export class ModuleNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  moduleKeywordLoc;

  /**
   * @type Node
   */
  constantPath;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ModuleNode.
   *
   * @param {string[]} locals
   * @param {Location} moduleKeywordLoc
   * @param {Node} constantPath
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   * @param {string} name
   * @param {Location} location
   */
  constructor(locals, moduleKeywordLoc, constantPath, body, endKeywordLoc, name, location) {
    this.locals = locals;
    this.moduleKeywordLoc = moduleKeywordLoc;
    this.constantPath = constantPath;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ModuleNode",
      locals: this.locals,
      moduleKeywordLoc: this.moduleKeywordLoc,
      constantPath: this.constantPath,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents a multi-target expression.
 *
 *     a, (b, c) = 1, 2, 3
 *        ^^^^^^
 */
export class MultiTargetNode {
  /**
   * @type Node[]
   */
  lefts;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  rights;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MultiTargetNode.
   *
   * @param {Node[]} lefts
   * @param {Node | null} rest
   * @param {Node[]} rights
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   * @param {Location} location
   */
  constructor(lefts, rest, rights, lparenLoc, rparenLoc, location) {
    this.lefts = lefts;
    this.rest = rest;
    this.rights = rights;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "MultiTargetNode",
      lefts: this.lefts,
      rest: this.rest,
      rights: this.rights,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      location: this.location
    };
  }
}

/**
 * Represents a write to a multi-target expression.
 *
 *     a, b, c = 1, 2, 3
 *     ^^^^^^^^^^^^^^^^^
 */
export class MultiWriteNode {
  /**
   * @type Node[]
   */
  lefts;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  rights;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new MultiWriteNode.
   *
   * @param {Node[]} lefts
   * @param {Node | null} rest
   * @param {Node[]} rights
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(lefts, rest, rights, lparenLoc, rparenLoc, operatorLoc, value, location) {
    this.lefts = lefts;
    this.rest = rest;
    this.rights = rights;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "MultiWriteNode",
      lefts: this.lefts,
      rest: this.rest,
      rights: this.rights,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `next` keyword.
 *
 *     next 1
 *     ^^^^^^
 */
export class NextNode {
  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new NextNode.
   *
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(arguments_, keywordLoc, location) {
    this.arguments_ = arguments_;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "NextNode",
      arguments: this.arguments_,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `nil` keyword.
 *
 *     nil
 *     ^^^
 */
export class NilNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new NilNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "NilNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of `**nil` inside method arguments.
 *
 *     def a(**nil)
 *           ^^^^^
 *     end
 */
export class NoKeywordsParameterNode {
  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new NoKeywordsParameterNode.
   *
   * @param {Location} operatorLoc
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(operatorLoc, keywordLoc, location) {
    this.operatorLoc = operatorLoc;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "NoKeywordsParameterNode",
      operatorLoc: this.operatorLoc,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents reading a numbered reference to a capture in the previous match.
 *
 *     $1
 *     ^^
 */
export class NumberedReferenceReadNode {
  /**
   * @type number
   */
  number;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new NumberedReferenceReadNode.
   *
   * @param {number} number
   * @param {Location} location
   */
  constructor(number, location) {
    this.number = number;
    this.location = location;
  }

  toJSON() {
    return {
      type: "NumberedReferenceReadNode",
      number: this.number,
      location: this.location
    };
  }
}

/**
 * Represents an optional keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: 1)
 *           ^^^^
 *     end
 */
export class OptionalKeywordParameterNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new OptionalKeywordParameterNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "OptionalKeywordParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents an optional parameter to a method, block, or lambda definition.
 *
 *     def a(b = 1)
 *           ^^^^^
 *     end
 */
export class OptionalParameterNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new OptionalParameterNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, value, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.location = location;
  }

  toJSON() {
    return {
      type: "OptionalParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `||` operator or the `or` keyword.
 *
 *     left or right
 *     ^^^^^^^^^^^^^
 */
export class OrNode {
  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new OrNode.
   *
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(left, right, operatorLoc, location) {
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "OrNode",
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the list of parameters on a method, block, or lambda definition.
 *
 *     def a(b, c, d)
 *           ^^^^^^^
 *     end
 */
export class ParametersNode {
  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node[]
   */
  optionals;

  /**
   * @type RestParameterNode | null
   */
  rest;

  /**
   * @type Node[]
   */
  posts;

  /**
   * @type Node[]
   */
  keywords;

  /**
   * @type Node | null
   */
  keywordRest;

  /**
   * @type BlockParameterNode | null
   */
  block;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ParametersNode.
   *
   * @param {Node[]} requireds
   * @param {Node[]} optionals
   * @param {RestParameterNode | null} rest
   * @param {Node[]} posts
   * @param {Node[]} keywords
   * @param {Node | null} keywordRest
   * @param {BlockParameterNode | null} block
   * @param {Location} location
   */
  constructor(requireds, optionals, rest, posts, keywords, keywordRest, block, location) {
    this.requireds = requireds;
    this.optionals = optionals;
    this.rest = rest;
    this.posts = posts;
    this.keywords = keywords;
    this.keywordRest = keywordRest;
    this.block = block;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ParametersNode",
      requireds: this.requireds,
      optionals: this.optionals,
      rest: this.rest,
      posts: this.posts,
      keywords: this.keywords,
      keywordRest: this.keywordRest,
      block: this.block,
      location: this.location
    };
  }
}

/**
 * Represents a parenthesized expression
 *
 *     (10 + 34)
 *     ^^^^^^^^^
 */
export class ParenthesesNode {
  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ParenthesesNode.
   *
   * @param {Node | null} body
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(body, openingLoc, closingLoc, location) {
    this.body = body;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ParenthesesNode",
      body: this.body,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `^` operator for pinning an expression in a
 * pattern matching expression.
 *
 *     foo in ^(bar)
 *            ^^^^^^
 */
export class PinnedExpressionNode {
  /**
   * @type Node
   */
  expression;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  lparenLoc;

  /**
   * @type Location
   */
  rparenLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new PinnedExpressionNode.
   *
   * @param {Node} expression
   * @param {Location} operatorLoc
   * @param {Location} lparenLoc
   * @param {Location} rparenLoc
   * @param {Location} location
   */
  constructor(expression, operatorLoc, lparenLoc, rparenLoc, location) {
    this.expression = expression;
    this.operatorLoc = operatorLoc;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "PinnedExpressionNode",
      expression: this.expression,
      operatorLoc: this.operatorLoc,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `^` operator for pinning a variable in a pattern
 * matching expression.
 *
 *     foo in ^bar
 *            ^^^^
 */
export class PinnedVariableNode {
  /**
   * @type Node
   */
  variable;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new PinnedVariableNode.
   *
   * @param {Node} variable
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(variable, operatorLoc, location) {
    this.variable = variable;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "PinnedVariableNode",
      variable: this.variable,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `END` keyword.
 *
 *     END { foo }
 *     ^^^^^^^^^^^
 */
export class PostExecutionNode {
  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new PostExecutionNode.
   *
   * @param {StatementsNode | null} statements
   * @param {Location} keywordLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(statements, keywordLoc, openingLoc, closingLoc, location) {
    this.statements = statements;
    this.keywordLoc = keywordLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "PostExecutionNode",
      statements: this.statements,
      keywordLoc: this.keywordLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `BEGIN` keyword.
 *
 *     BEGIN { foo }
 *     ^^^^^^^^^^^^^
 */
export class PreExecutionNode {
  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new PreExecutionNode.
   *
   * @param {StatementsNode | null} statements
   * @param {Location} keywordLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {Location} location
   */
  constructor(statements, keywordLoc, openingLoc, closingLoc, location) {
    this.statements = statements;
    this.keywordLoc = keywordLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "PreExecutionNode",
      statements: this.statements,
      keywordLoc: this.keywordLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      location: this.location
    };
  }
}

/**
 * The top level node of any parse tree.
 */
export class ProgramNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type StatementsNode
   */
  statements;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ProgramNode.
   *
   * @param {string[]} locals
   * @param {StatementsNode} statements
   * @param {Location} location
   */
  constructor(locals, statements, location) {
    this.locals = locals;
    this.statements = statements;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ProgramNode",
      locals: this.locals,
      statements: this.statements,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `..` or `...` operators.
 *
 *     1..2
 *     ^^^^
 *
 *     c if a =~ /left/ ... b =~ /right/
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 */
export class RangeNode {
  /**
   * @type Node | null
   */
  left;

  /**
   * @type Node | null
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RangeNode.
   *
   * @param {Node | null} left
   * @param {Node | null} right
   * @param {Location} operatorLoc
   * @param {number} flags
   * @param {Location} location
   */
  constructor(left, right, operatorLoc, flags, location) {
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the EXCLUDE_END flag.
   *
   * @returns {boolean}
   */
  isExcludeEnd() {
    return (this.#flags & RangeFlags.EXCLUDE_END) !== 0;
  }

  toJSON() {
    return {
      type: "RangeNode",
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a rational number literal.
 *
 *     1.0r
 *     ^^^^
 */
export class RationalNode {
  /**
   * @type Node
   */
  numeric;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RationalNode.
   *
   * @param {Node} numeric
   * @param {Location} location
   */
  constructor(numeric, location) {
    this.numeric = numeric;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RationalNode",
      numeric: this.numeric,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `redo` keyword.
 *
 *     redo
 *     ^^^^
 */
export class RedoNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RedoNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "RedoNode",
      location: this.location
    };
  }
}

/**
 * Represents a regular expression literal with no interpolation.
 *
 *     /foo/i
 *     ^^^^^^
 */
export class RegularExpressionNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type string
   */
  unescaped;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RegularExpressionNode.
   *
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {string} unescaped
   * @param {number} flags
   * @param {Location} location
   */
  constructor(openingLoc, contentLoc, closingLoc, unescaped, flags, location) {
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  toJSON() {
    return {
      type: "RegularExpressionNode",
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents a required keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: )
 *           ^^
 *     end
 */
export class RequiredKeywordParameterNode {
  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RequiredKeywordParameterNode.
   *
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RequiredKeywordParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      location: this.location
    };
  }
}

/**
 * Represents a required parameter to a method, block, or lambda definition.
 *
 *     def a(b)
 *           ^
 *     end
 */
export class RequiredParameterNode {
  /**
   * @type string
   */
  name;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RequiredParameterNode.
   *
   * @param {string} name
   * @param {Location} location
   */
  constructor(name, location) {
    this.name = name;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RequiredParameterNode",
      name: this.name,
      location: this.location
    };
  }
}

/**
 * Represents an expression modified with a rescue.
 *
 *     foo rescue nil
 *     ^^^^^^^^^^^^^^
 */
export class RescueModifierNode {
  /**
   * @type Node
   */
  expression;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node
   */
  rescueExpression;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RescueModifierNode.
   *
   * @param {Node} expression
   * @param {Location} keywordLoc
   * @param {Node} rescueExpression
   * @param {Location} location
   */
  constructor(expression, keywordLoc, rescueExpression, location) {
    this.expression = expression;
    this.keywordLoc = keywordLoc;
    this.rescueExpression = rescueExpression;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RescueModifierNode",
      expression: this.expression,
      keywordLoc: this.keywordLoc,
      rescueExpression: this.rescueExpression,
      location: this.location
    };
  }
}

/**
 * Represents a rescue statement.
 *
 *     begin
 *     rescue Foo, *splat, Bar => ex
 *       foo
 *     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *     end
 *
 * `Foo, *splat, Bar` are in the `exceptions` field.
 * `ex` is in the `exception` field.
 */
export class RescueNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node[]
   */
  exceptions;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type Node | null
   */
  reference;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type RescueNode | null
   */
  consequent;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RescueNode.
   *
   * @param {Location} keywordLoc
   * @param {Node[]} exceptions
   * @param {Location | null} operatorLoc
   * @param {Node | null} reference
   * @param {StatementsNode | null} statements
   * @param {RescueNode | null} consequent
   * @param {Location} location
   */
  constructor(keywordLoc, exceptions, operatorLoc, reference, statements, consequent, location) {
    this.keywordLoc = keywordLoc;
    this.exceptions = exceptions;
    this.operatorLoc = operatorLoc;
    this.reference = reference;
    this.statements = statements;
    this.consequent = consequent;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RescueNode",
      keywordLoc: this.keywordLoc,
      exceptions: this.exceptions,
      operatorLoc: this.operatorLoc,
      reference: this.reference,
      statements: this.statements,
      consequent: this.consequent,
      location: this.location
    };
  }
}

/**
 * Represents a rest parameter to a method, block, or lambda definition.
 *
 *     def a(*b)
 *           ^^
 *     end
 */
export class RestParameterNode {
  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RestParameterNode.
   *
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   * @param {Location} location
   */
  constructor(name, nameLoc, operatorLoc, location) {
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "RestParameterNode",
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `retry` keyword.
 *
 *     retry
 *     ^^^^^
 */
export class RetryNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new RetryNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "RetryNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the `return` keyword.
 *
 *     return 1
 *     ^^^^^^^^
 */
export class ReturnNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new ReturnNode.
   *
   * @param {Location} keywordLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} location
   */
  constructor(keywordLoc, arguments_, location) {
    this.keywordLoc = keywordLoc;
    this.arguments_ = arguments_;
    this.location = location;
  }

  toJSON() {
    return {
      type: "ReturnNode",
      keywordLoc: this.keywordLoc,
      arguments: this.arguments_,
      location: this.location
    };
  }
}

/**
 * Represents the `self` keyword.
 *
 *     self
 *     ^^^^
 */
export class SelfNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SelfNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "SelfNode",
      location: this.location
    };
  }
}

/**
 * Represents a singleton class declaration involving the `class` keyword.
 *
 *     class << self end
 *     ^^^^^^^^^^^^^^^^^
 */
export class SingletonClassNode {
  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  classKeywordLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  expression;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SingletonClassNode.
   *
   * @param {string[]} locals
   * @param {Location} classKeywordLoc
   * @param {Location} operatorLoc
   * @param {Node} expression
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   * @param {Location} location
   */
  constructor(locals, classKeywordLoc, operatorLoc, expression, body, endKeywordLoc, location) {
    this.locals = locals;
    this.classKeywordLoc = classKeywordLoc;
    this.operatorLoc = operatorLoc;
    this.expression = expression;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "SingletonClassNode",
      locals: this.locals,
      classKeywordLoc: this.classKeywordLoc,
      operatorLoc: this.operatorLoc,
      expression: this.expression,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `__ENCODING__` keyword.
 *
 *     __ENCODING__
 *     ^^^^^^^^^^^^
 */
export class SourceEncodingNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SourceEncodingNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "SourceEncodingNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the `__FILE__` keyword.
 *
 *     __FILE__
 *     ^^^^^^^^
 */
export class SourceFileNode {
  /**
   * @type string
   */
  filepath;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SourceFileNode.
   *
   * @param {string} filepath
   * @param {Location} location
   */
  constructor(filepath, location) {
    this.filepath = filepath;
    this.location = location;
  }

  toJSON() {
    return {
      type: "SourceFileNode",
      filepath: this.filepath,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `__LINE__` keyword.
 *
 *     __LINE__
 *     ^^^^^^^^
 */
export class SourceLineNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SourceLineNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "SourceLineNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the splat operator.
 *
 *     [*a]
 *      ^^
 */
export class SplatNode {
  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node | null
   */
  expression;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SplatNode.
   *
   * @param {Location} operatorLoc
   * @param {Node | null} expression
   * @param {Location} location
   */
  constructor(operatorLoc, expression, location) {
    this.operatorLoc = operatorLoc;
    this.expression = expression;
    this.location = location;
  }

  toJSON() {
    return {
      type: "SplatNode",
      operatorLoc: this.operatorLoc,
      expression: this.expression,
      location: this.location
    };
  }
}

/**
 * Represents a set of statements contained within some scope.
 *
 *     foo; bar; baz
 *     ^^^^^^^^^^^^^
 */
export class StatementsNode {
  /**
   * @type Node[]
   */
  body;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new StatementsNode.
   *
   * @param {Node[]} body
   * @param {Location} location
   */
  constructor(body, location) {
    this.body = body;
    this.location = location;
  }

  toJSON() {
    return {
      type: "StatementsNode",
      body: this.body,
      location: this.location
    };
  }
}

/**
 * Represents the use of compile-time string concatenation.
 *
 *     "foo" "bar"
 *     ^^^^^^^^^^^
 */
export class StringConcatNode {
  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new StringConcatNode.
   *
   * @param {Node} left
   * @param {Node} right
   * @param {Location} location
   */
  constructor(left, right, location) {
    this.left = left;
    this.right = right;
    this.location = location;
  }

  toJSON() {
    return {
      type: "StringConcatNode",
      left: this.left,
      right: this.right,
      location: this.location
    };
  }
}

/**
 * Represents a string literal, a string contained within a `%w` list, or
 * plain string content within an interpolated string.
 *
 *     "foo"
 *     ^^^^^
 *
 *     %w[foo]
 *        ^^^
 *
 *     "foo #{bar} baz"
 *      ^^^^      ^^^^
 */
export class StringNode {
  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type string
   */
  unescaped;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new StringNode.
   *
   * @param {number} flags
   * @param {Location | null} openingLoc
   * @param {Location} contentLoc
   * @param {Location | null} closingLoc
   * @param {string} unescaped
   * @param {Location} location
   */
  constructor(flags, openingLoc, contentLoc, closingLoc, unescaped, location) {
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
    this.location = location;
  }

  /**
   * True if this node has the FROZEN flag.
   *
   * @returns {boolean}
   */
  isFrozen() {
    return (this.#flags & StringFlags.FROZEN) !== 0;
  }

  toJSON() {
    return {
      type: "StringNode",
      flags: this.#flags,
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `super` keyword with parentheses or arguments.
 *
 *     super()
 *     ^^^^^^^
 *
 *     super foo, bar
 *     ^^^^^^^^^^^^^^
 */
export class SuperNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SuperNode.
   *
   * @param {Location} keywordLoc
   * @param {Location | null} lparenLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} rparenLoc
   * @param {Node | null} block
   * @param {Location} location
   */
  constructor(keywordLoc, lparenLoc, arguments_, rparenLoc, block, location) {
    this.keywordLoc = keywordLoc;
    this.lparenLoc = lparenLoc;
    this.arguments_ = arguments_;
    this.rparenLoc = rparenLoc;
    this.block = block;
    this.location = location;
  }

  toJSON() {
    return {
      type: "SuperNode",
      keywordLoc: this.keywordLoc,
      lparenLoc: this.lparenLoc,
      arguments: this.arguments_,
      rparenLoc: this.rparenLoc,
      block: this.block,
      location: this.location
    };
  }
}

/**
 * Represents a symbol literal or a symbol contained within a `%i` list.
 *
 *     :foo
 *     ^^^^
 *
 *     %i[foo]
 *        ^^^
 */
export class SymbolNode {
  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  valueLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type string
   */
  unescaped;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new SymbolNode.
   *
   * @param {Location | null} openingLoc
   * @param {Location | null} valueLoc
   * @param {Location | null} closingLoc
   * @param {string} unescaped
   * @param {Location} location
   */
  constructor(openingLoc, valueLoc, closingLoc, unescaped, location) {
    this.openingLoc = openingLoc;
    this.valueLoc = valueLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
    this.location = location;
  }

  toJSON() {
    return {
      type: "SymbolNode",
      openingLoc: this.openingLoc,
      valueLoc: this.valueLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
      location: this.location
    };
  }
}

/**
 * Represents the use of the literal `true` keyword.
 *
 *     true
 *     ^^^^
 */
export class TrueNode {
  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new TrueNode.
   *
   * @param {Location} location
   */
  constructor(location) {
    this.location = location;
  }

  toJSON() {
    return {
      type: "TrueNode",
      location: this.location
    };
  }
}

/**
 * Represents the use of the `undef` keyword.
 *
 *     undef :foo, :bar, :baz
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class UndefNode {
  /**
   * @type Node[]
   */
  names;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new UndefNode.
   *
   * @param {Node[]} names
   * @param {Location} keywordLoc
   * @param {Location} location
   */
  constructor(names, keywordLoc, location) {
    this.names = names;
    this.keywordLoc = keywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "UndefNode",
      names: this.names,
      keywordLoc: this.keywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `unless` keyword, either in the block form or the modifier form.
 *
 *     bar unless foo
 *     ^^^^^^^^^^^^^^
 *
 *     unless foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class UnlessNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type ElseNode | null
   */
  consequent;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new UnlessNode.
   *
   * @param {Location} keywordLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   * @param {ElseNode | null} consequent
   * @param {Location | null} endKeywordLoc
   * @param {Location} location
   */
  constructor(keywordLoc, predicate, statements, consequent, endKeywordLoc, location) {
    this.keywordLoc = keywordLoc;
    this.predicate = predicate;
    this.statements = statements;
    this.consequent = consequent;
    this.endKeywordLoc = endKeywordLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "UnlessNode",
      keywordLoc: this.keywordLoc,
      predicate: this.predicate,
      statements: this.statements,
      consequent: this.consequent,
      endKeywordLoc: this.endKeywordLoc,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `until` keyword, either in the block form or the modifier form.
 *
 *     bar until foo
 *     ^^^^^^^^^^^^^
 *
 *     until foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class UntilNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new UntilNode.
   *
   * @param {Location} keywordLoc
   * @param {Location | null} closingLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   * @param {number} flags
   * @param {Location} location
   */
  constructor(keywordLoc, closingLoc, predicate, statements, flags, location) {
    this.keywordLoc = keywordLoc;
    this.closingLoc = closingLoc;
    this.predicate = predicate;
    this.statements = statements;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the BEGIN_MODIFIER flag.
   *
   * @returns {boolean}
   */
  isBeginModifier() {
    return (this.#flags & LoopFlags.BEGIN_MODIFIER) !== 0;
  }

  toJSON() {
    return {
      type: "UntilNode",
      keywordLoc: this.keywordLoc,
      closingLoc: this.closingLoc,
      predicate: this.predicate,
      statements: this.statements,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `when` keyword within a case statement.
 *
 *     case true
 *     when true
 *     ^^^^^^^^^
 *     end
 */
export class WhenNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node[]
   */
  conditions;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new WhenNode.
   *
   * @param {Location} keywordLoc
   * @param {Node[]} conditions
   * @param {StatementsNode | null} statements
   * @param {Location} location
   */
  constructor(keywordLoc, conditions, statements, location) {
    this.keywordLoc = keywordLoc;
    this.conditions = conditions;
    this.statements = statements;
    this.location = location;
  }

  toJSON() {
    return {
      type: "WhenNode",
      keywordLoc: this.keywordLoc,
      conditions: this.conditions,
      statements: this.statements,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `while` keyword, either in the block form or the modifier form.
 *
 *     bar while foo
 *     ^^^^^^^^^^^^^
 *
 *     while foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class WhileNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type number
   */
  #flags;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new WhileNode.
   *
   * @param {Location} keywordLoc
   * @param {Location | null} closingLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   * @param {number} flags
   * @param {Location} location
   */
  constructor(keywordLoc, closingLoc, predicate, statements, flags, location) {
    this.keywordLoc = keywordLoc;
    this.closingLoc = closingLoc;
    this.predicate = predicate;
    this.statements = statements;
    this.#flags = flags;
    this.location = location;
  }

  /**
   * True if this node has the BEGIN_MODIFIER flag.
   *
   * @returns {boolean}
   */
  isBeginModifier() {
    return (this.#flags & LoopFlags.BEGIN_MODIFIER) !== 0;
  }

  toJSON() {
    return {
      type: "WhileNode",
      keywordLoc: this.keywordLoc,
      closingLoc: this.closingLoc,
      predicate: this.predicate,
      statements: this.statements,
      flags: this.#flags,
      location: this.location
    };
  }
}

/**
 * Represents an xstring literal with no interpolation.
 *
 *     `foo`
 *     ^^^^^
 */
export class XStringNode {
  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type string
   */
  unescaped;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new XStringNode.
   *
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {string} unescaped
   * @param {Location} location
   */
  constructor(openingLoc, contentLoc, closingLoc, unescaped, location) {
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
    this.location = location;
  }

  toJSON() {
    return {
      type: "XStringNode",
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
      location: this.location
    };
  }
}

/**
 * Represents the use of the `yield` keyword.
 *
 *     yield 1
 *     ^^^^^^^
 */
export class YieldNode {
  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type {Location}
   */
  location;

  /**
   * Construct a new YieldNode.
   *
   * @param {Location} keywordLoc
   * @param {Location | null} lparenLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} rparenLoc
   * @param {Location} location
   */
  constructor(keywordLoc, lparenLoc, arguments_, rparenLoc, location) {
    this.keywordLoc = keywordLoc;
    this.lparenLoc = lparenLoc;
    this.arguments_ = arguments_;
    this.rparenLoc = rparenLoc;
    this.location = location;
  }

  toJSON() {
    return {
      type: "YieldNode",
      keywordLoc: this.keywordLoc,
      lparenLoc: this.lparenLoc,
      arguments: this.arguments_,
      rparenLoc: this.rparenLoc,
      location: this.location
    };
  }
}

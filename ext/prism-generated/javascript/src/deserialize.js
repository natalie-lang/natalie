/******************************************************************************/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/javascript/src/deserialize.js.erb                                */
/* if you are looking to modify the                                           */
/* template                                                                   */
/******************************************************************************/
import * as nodes from "./nodes.js";

const MAJOR_VERSION = 0;
const MINOR_VERSION = 17;
const PATCH_VERSION = 1;

class SerializationBuffer {
  constructor(source, array) {
    this.source = source;
    this.array = array;
    this.index = 0;
  }

  readByte() {
    const result = this.array[this.index];
    this.index += 1;
    return result;
  }

  readBytes(length) {
    const result = this.array.slice(this.index, this.index + length);
    this.index += length;
    return result;
  }

  readString(length) {
    return new TextDecoder().decode(this.readBytes(length));
  }

  // Read a 32-bit unsigned integer in little-endian format.
  readUint32() {
    const result = this.scanUint32(this.index);
    this.index += 4;
    return result;
  }

  scanUint32(offset) {
    const bytes = this.array.slice(offset, offset + 4);
    return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
  }

  readVarInt() {
    let result = 0;
    let shift = 0;

    while (true) {
      const byte = this.readByte();
      result += (byte & 0x7f) << shift;
      shift += 7;

      if ((byte & 0x80) === 0) {
        break;
      }
    }

    return result;
  }

  readLocation() {
    return { startOffset: this.readVarInt(), length: this.readVarInt() };
  }

  readOptionalLocationField() {
    if (this.readByte() != 0) {
      return this.readLocation();
    } else {
      return null;
    }
  }

  readStringField() {
    const type = this.readByte();

    switch (type) {
      case 1: {
        const startOffset = this.readVarInt();
        const length = this.readVarInt();
        return new TextDecoder().decode(this.source.slice(startOffset, startOffset + length));
      }
      case 2:
        return this.readString(this.readVarInt());
      default:
        throw new Error(`Unknown serialized string type: ${type}`);
    }
  }

  scanConstant(constantPoolOffset, constantIndex) {
    const offset = constantPoolOffset + constantIndex * 8;
    const startOffset = this.scanUint32(offset);
    const length = this.scanUint32(offset + 4);

    if (startOffset & (1 << 31)) {
      startOffset &= (1 << 31) - 1;
      return new TextDecoder().decode(this.array.slice(startOffset, startOffset + length));
    } else {
      return new TextDecoder().decode(this.source.slice(startOffset, startOffset + length));
    }
  }
}

/**
 * A location in the source code.
 *
 * @typedef {{ startOffset: number, length: number }} Location
 */

/**
 * A comment in the source code.
 *
 * @typedef {{ type: number, location: Location }} Comment
 */

/**
 * A magic comment in the source code.
 *
 * @typedef {{ startLocation: Location, endLocation: Location }} MagicComment
 */

/**
 * An error in the source code.
 *
 * @typedef {{ message: string, location: Location }} ParseError
 */

/**
 * A warning in the source code.
 *
 * @typedef {{ message: string, location: Location }} ParseWarning
 */

/**
 * The result of parsing the source code.
 *
 * @typedef {{ value: ProgramNode, comments: Comment[], magicComments: MagicComment[], errors: ParseError[], warnings: ParseWarning[] }} ParseResult
 */

/**
 * The result of calling parse.
 */
export class ParseResult {
  /**
   * @type {nodes.ProgramNode}
   */
  value;

  /**
   * @type {Comment[]}
   */
  comments;

  /**
   * @type {MagicComment[]}
   */
  magicComments;

  /**
   * @type {ParseError[]}
   */
  errors;

  /**
   * @type {ParseWarning[]}
   */
  warnings;

  /**
   * @param {nodes.ProgramNode} value
   * @param {Comment[]} comments
   * @param {MagicComment[]} magicComments
   * @param {ParseError[]} errors
   * @param {ParseWarning[]} warnings
   */
  constructor(value, comments, magicComments, errors, warnings) {
    this.value = value;
    this.comments = comments;
    this.magicComments = magicComments;
    this.errors = errors;
    this.warnings = warnings;
  }
}

/**
 * Accept two Uint8Arrays, one for the source and one for the serialized format.
 * Return the AST corresponding to the serialized form.
 *
 * @param {Uint8Array} source
 * @param {Uint8Array} array
 * @returns {ParseResult}
 * @throws {Error}
 */
export function deserialize(source, array) {
  const buffer = new SerializationBuffer(source, array);

  if (buffer.readString(5) !== "PRISM") {
    throw new Error("Invalid serialization");
  }

  if ((buffer.readByte() != MAJOR_VERSION) || (buffer.readByte() != MINOR_VERSION) || (buffer.readByte() != PATCH_VERSION)) {
    throw new Error("Invalid serialization");
  }

  if (buffer.readByte() != 0) {
    throw new Error("Invalid serialization (location fields must be included but are not)");
  }

  // Skip past the encoding, it means nothing to us in JavaScript.
  buffer.readString(buffer.readVarInt());

  // Skip past the start line, as we don't support that option yet in
  // JavaScript.
  buffer.readVarInt();

  const comments = Array.from({ length: buffer.readVarInt() }, () => ({
    type: buffer.readVarInt(),
    location: buffer.readLocation()
  }));

  const magicComments = Array.from({ length: buffer.readVarInt() }, () => ({
    startLocation: buffer.readLocation(),
    endLocation: buffer.readLocation()
  }));

  const errors = Array.from({ length: buffer.readVarInt() }, () => ({
    message: buffer.readString(buffer.readVarInt()),
    location: buffer.readLocation()
  }));

  const warnings = Array.from({ length: buffer.readVarInt() }, () => ({
    message: buffer.readString(buffer.readVarInt()),
    location: buffer.readLocation()
  }));

  const constantPoolOffset = buffer.readUint32();
  const constants = Array.from({ length: buffer.readVarInt() }, () => null);

  return new ParseResult(readRequiredNode(), comments, magicComments, errors, warnings);

  function readRequiredNode() {
    const type = buffer.readByte();
    const location = buffer.readLocation();

    switch (type) {
      case 1:
        return new nodes.AliasGlobalVariableNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 2:
        return new nodes.AliasMethodNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 3:
        return new nodes.AlternationPatternNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 4:
        return new nodes.AndNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 5:
        return new nodes.ArgumentsNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readVarInt(), location);
      case 6:
        return new nodes.ArrayNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 7:
        return new nodes.ArrayPatternNode(readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 8:
        return new nodes.AssocNode(readRequiredNode(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      case 9:
        return new nodes.AssocSplatNode(readOptionalNode(), buffer.readLocation(), location);
      case 10:
        return new nodes.BackReferenceReadNode(readRequiredConstant(), location);
      case 11:
        return new nodes.BeginNode(buffer.readOptionalLocationField(), readOptionalNode(), readOptionalNode(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      case 12:
        return new nodes.BlockArgumentNode(readOptionalNode(), buffer.readLocation(), location);
      case 13:
        return new nodes.BlockLocalVariableNode(readRequiredConstant(), location);
      case 14:
        return new nodes.BlockNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), readOptionalNode(), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), location);
      case 15:
        return new nodes.BlockParameterNode(readOptionalConstant(), buffer.readOptionalLocationField(), buffer.readLocation(), location);
      case 16:
        return new nodes.BlockParametersNode(readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 17:
        return new nodes.BreakNode(readOptionalNode(), buffer.readLocation(), location);
      case 18:
        return new nodes.CallAndWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readVarInt(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), location);
      case 19:
        return new nodes.CallNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), readOptionalNode(), buffer.readOptionalLocationField(), readOptionalNode(), buffer.readVarInt(), readRequiredConstant(), location);
      case 20:
        return new nodes.CallOperatorWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readVarInt(), readRequiredConstant(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), location);
      case 21:
        return new nodes.CallOrWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readVarInt(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), location);
      case 22:
        return new nodes.CapturePatternNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 23:
        return new nodes.CaseNode(readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), location);
      case 24:
        return new nodes.ClassNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), readRequiredNode(), buffer.readOptionalLocationField(), readOptionalNode(), readOptionalNode(), buffer.readLocation(), readRequiredConstant(), location);
      case 25:
        return new nodes.ClassVariableAndWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 26:
        return new nodes.ClassVariableOperatorWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), location);
      case 27:
        return new nodes.ClassVariableOrWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 28:
        return new nodes.ClassVariableReadNode(readRequiredConstant(), location);
      case 29:
        return new nodes.ClassVariableTargetNode(readRequiredConstant(), location);
      case 30:
        return new nodes.ClassVariableWriteNode(readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readOptionalLocationField(), location);
      case 31:
        return new nodes.ConstantAndWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 32:
        return new nodes.ConstantOperatorWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), location);
      case 33:
        return new nodes.ConstantOrWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 34:
        return new nodes.ConstantPathAndWriteNode(readRequiredNode(), buffer.readLocation(), readRequiredNode(), location);
      case 35:
        return new nodes.ConstantPathNode(readOptionalNode(), readRequiredNode(), buffer.readLocation(), location);
      case 36:
        return new nodes.ConstantPathOperatorWriteNode(readRequiredNode(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), location);
      case 37:
        return new nodes.ConstantPathOrWriteNode(readRequiredNode(), buffer.readLocation(), readRequiredNode(), location);
      case 38:
        return new nodes.ConstantPathTargetNode(readOptionalNode(), readRequiredNode(), buffer.readLocation(), location);
      case 39:
        return new nodes.ConstantPathWriteNode(readRequiredNode(), buffer.readLocation(), readRequiredNode(), location);
      case 40:
        return new nodes.ConstantReadNode(readRequiredConstant(), location);
      case 41:
        return new nodes.ConstantTargetNode(readRequiredConstant(), location);
      case 42:
        return new nodes.ConstantWriteNode(readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation(), location);
      case 43:
        buffer.readUint32();
        return new nodes.DefNode(readRequiredConstant(), buffer.readLocation(), readOptionalNode(), readOptionalNode(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 44:
        return new nodes.DefinedNode(buffer.readOptionalLocationField(), readRequiredNode(), buffer.readOptionalLocationField(), buffer.readLocation(), location);
      case 45:
        return new nodes.ElseNode(buffer.readLocation(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      case 46:
        return new nodes.EmbeddedStatementsNode(buffer.readLocation(), readOptionalNode(), buffer.readLocation(), location);
      case 47:
        return new nodes.EmbeddedVariableNode(buffer.readLocation(), readRequiredNode(), location);
      case 48:
        return new nodes.EnsureNode(buffer.readLocation(), readOptionalNode(), buffer.readLocation(), location);
      case 49:
        return new nodes.FalseNode(location);
      case 50:
        return new nodes.FindPatternNode(readOptionalNode(), readRequiredNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readRequiredNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 51:
        return new nodes.FlipFlopNode(readOptionalNode(), readOptionalNode(), buffer.readLocation(), buffer.readVarInt(), location);
      case 52:
        return new nodes.FloatNode(location);
      case 53:
        return new nodes.ForNode(readRequiredNode(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readOptionalLocationField(), buffer.readLocation(), location);
      case 54:
        return new nodes.ForwardingArgumentsNode(location);
      case 55:
        return new nodes.ForwardingParameterNode(location);
      case 56:
        return new nodes.ForwardingSuperNode(readOptionalNode(), location);
      case 57:
        return new nodes.GlobalVariableAndWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 58:
        return new nodes.GlobalVariableOperatorWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), location);
      case 59:
        return new nodes.GlobalVariableOrWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 60:
        return new nodes.GlobalVariableReadNode(readRequiredConstant(), location);
      case 61:
        return new nodes.GlobalVariableTargetNode(readRequiredConstant(), location);
      case 62:
        return new nodes.GlobalVariableWriteNode(readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation(), location);
      case 63:
        return new nodes.HashNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation(), location);
      case 64:
        return new nodes.HashPatternNode(readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 65:
        return new nodes.IfNode(buffer.readOptionalLocationField(), readRequiredNode(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      case 66:
        return new nodes.ImaginaryNode(readRequiredNode(), location);
      case 67:
        return new nodes.ImplicitNode(readRequiredNode(), location);
      case 68:
        return new nodes.InNode(readRequiredNode(), readOptionalNode(), buffer.readLocation(), buffer.readOptionalLocationField(), location);
      case 69:
        return new nodes.IndexAndWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), buffer.readVarInt(), buffer.readLocation(), readRequiredNode(), location);
      case 70:
        return new nodes.IndexOperatorWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), location);
      case 71:
        return new nodes.IndexOrWriteNode(readOptionalNode(), buffer.readOptionalLocationField(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), buffer.readVarInt(), buffer.readLocation(), readRequiredNode(), location);
      case 72:
        return new nodes.InstanceVariableAndWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 73:
        return new nodes.InstanceVariableOperatorWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), location);
      case 74:
        return new nodes.InstanceVariableOrWriteNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 75:
        return new nodes.InstanceVariableReadNode(readRequiredConstant(), location);
      case 76:
        return new nodes.InstanceVariableTargetNode(readRequiredConstant(), location);
      case 77:
        return new nodes.InstanceVariableWriteNode(readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation(), location);
      case 78:
        return new nodes.IntegerNode(buffer.readVarInt(), location);
      case 79:
        return new nodes.InterpolatedMatchLastLineNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation(), buffer.readVarInt(), location);
      case 80:
        return new nodes.InterpolatedRegularExpressionNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation(), buffer.readVarInt(), location);
      case 81:
        return new nodes.InterpolatedStringNode(buffer.readOptionalLocationField(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), location);
      case 82:
        return new nodes.InterpolatedSymbolNode(buffer.readOptionalLocationField(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), location);
      case 83:
        return new nodes.InterpolatedXStringNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation(), location);
      case 84:
        return new nodes.KeywordHashNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), location);
      case 85:
        return new nodes.KeywordRestParameterNode(readOptionalConstant(), buffer.readOptionalLocationField(), buffer.readLocation(), location);
      case 86:
        return new nodes.LambdaNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), readOptionalNode(), readOptionalNode(), location);
      case 87:
        return new nodes.LocalVariableAndWriteNode(buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), buffer.readVarInt(), location);
      case 88:
        return new nodes.LocalVariableOperatorWriteNode(buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), readRequiredConstant(), buffer.readVarInt(), location);
      case 89:
        return new nodes.LocalVariableOrWriteNode(buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), buffer.readVarInt(), location);
      case 90:
        return new nodes.LocalVariableReadNode(readRequiredConstant(), buffer.readVarInt(), location);
      case 91:
        return new nodes.LocalVariableTargetNode(readRequiredConstant(), buffer.readVarInt(), location);
      case 92:
        return new nodes.LocalVariableWriteNode(readRequiredConstant(), buffer.readVarInt(), buffer.readLocation(), readRequiredNode(), buffer.readLocation(), location);
      case 93:
        return new nodes.MatchLastLineNode(buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(), buffer.readVarInt(), location);
      case 94:
        return new nodes.MatchPredicateNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 95:
        return new nodes.MatchRequiredNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 96:
        return new nodes.MatchWriteNode(readRequiredNode(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), location);
      case 97:
        return new nodes.MissingNode(location);
      case 98:
        return new nodes.ModuleNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), readRequiredConstant(), location);
      case 99:
        return new nodes.MultiTargetNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), location);
      case 100:
        return new nodes.MultiWriteNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readLocation(), readRequiredNode(), location);
      case 101:
        return new nodes.NextNode(readOptionalNode(), buffer.readLocation(), location);
      case 102:
        return new nodes.NilNode(location);
      case 103:
        return new nodes.NoKeywordsParameterNode(buffer.readLocation(), buffer.readLocation(), location);
      case 104:
        return new nodes.NumberedReferenceReadNode(buffer.readVarInt(), location);
      case 105:
        return new nodes.OptionalKeywordParameterNode(readRequiredConstant(), buffer.readLocation(), readRequiredNode(), location);
      case 106:
        return new nodes.OptionalParameterNode(readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), location);
      case 107:
        return new nodes.OrNode(readRequiredNode(), readRequiredNode(), buffer.readLocation(), location);
      case 108:
        return new nodes.ParametersNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), readOptionalNode(), location);
      case 109:
        return new nodes.ParenthesesNode(readOptionalNode(), buffer.readLocation(), buffer.readLocation(), location);
      case 110:
        return new nodes.PinnedExpressionNode(readRequiredNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), location);
      case 111:
        return new nodes.PinnedVariableNode(readRequiredNode(), buffer.readLocation(), location);
      case 112:
        return new nodes.PostExecutionNode(readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), location);
      case 113:
        return new nodes.PreExecutionNode(readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), location);
      case 114:
        return new nodes.ProgramNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), readRequiredNode(), location);
      case 115:
        return new nodes.RangeNode(readOptionalNode(), readOptionalNode(), buffer.readLocation(), buffer.readVarInt(), location);
      case 116:
        return new nodes.RationalNode(readRequiredNode(), location);
      case 117:
        return new nodes.RedoNode(location);
      case 118:
        return new nodes.RegularExpressionNode(buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(), buffer.readVarInt(), location);
      case 119:
        return new nodes.RequiredKeywordParameterNode(readRequiredConstant(), buffer.readLocation(), location);
      case 120:
        return new nodes.RequiredParameterNode(readRequiredConstant(), location);
      case 121:
        return new nodes.RescueModifierNode(readRequiredNode(), buffer.readLocation(), readRequiredNode(), location);
      case 122:
        return new nodes.RescueNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocationField(), readOptionalNode(), readOptionalNode(), readOptionalNode(), location);
      case 123:
        return new nodes.RestParameterNode(readOptionalConstant(), buffer.readOptionalLocationField(), buffer.readLocation(), location);
      case 124:
        return new nodes.RetryNode(location);
      case 125:
        return new nodes.ReturnNode(buffer.readLocation(), readOptionalNode(), location);
      case 126:
        return new nodes.SelfNode(location);
      case 127:
        return new nodes.SingletonClassNode(Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), location);
      case 128:
        return new nodes.SourceEncodingNode(location);
      case 129:
        return new nodes.SourceFileNode(buffer.readStringField(), location);
      case 130:
        return new nodes.SourceLineNode(location);
      case 131:
        return new nodes.SplatNode(buffer.readLocation(), readOptionalNode(), location);
      case 132:
        return new nodes.StatementsNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), location);
      case 133:
        return new nodes.StringConcatNode(readRequiredNode(), readRequiredNode(), location);
      case 134:
        return new nodes.StringNode(buffer.readVarInt(), buffer.readOptionalLocationField(), buffer.readLocation(), buffer.readOptionalLocationField(), buffer.readStringField(), location);
      case 135:
        return new nodes.SuperNode(buffer.readLocation(), buffer.readOptionalLocationField(), readOptionalNode(), buffer.readOptionalLocationField(), readOptionalNode(), location);
      case 136:
        return new nodes.SymbolNode(buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readOptionalLocationField(), buffer.readStringField(), location);
      case 137:
        return new nodes.TrueNode(location);
      case 138:
        return new nodes.UndefNode(Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation(), location);
      case 139:
        return new nodes.UnlessNode(buffer.readLocation(), readRequiredNode(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      case 140:
        return new nodes.UntilNode(buffer.readLocation(), buffer.readOptionalLocationField(), readRequiredNode(), readOptionalNode(), buffer.readVarInt(), location);
      case 141:
        return new nodes.WhenNode(buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), location);
      case 142:
        return new nodes.WhileNode(buffer.readLocation(), buffer.readOptionalLocationField(), readRequiredNode(), readOptionalNode(), buffer.readVarInt(), location);
      case 143:
        return new nodes.XStringNode(buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(), location);
      case 144:
        return new nodes.YieldNode(buffer.readLocation(), buffer.readOptionalLocationField(), readOptionalNode(), buffer.readOptionalLocationField(), location);
      default:
        throw new Error(`Unknown node type: ${type}`);
    }
  }

  function readOptionalNode() {
    if (buffer.readByte() != 0) {
      buffer.index -= 1;
      return readRequiredNode();
    } else {
      return null;
    }
  }

  function scanConstant(constantIndex) {
    if (constants[constantIndex] === null) {
      constants[constantIndex] = buffer.scanConstant(constantPoolOffset, constantIndex);
    }

    return constants[constantIndex];
  }

  function readRequiredConstant() {
    return scanConstant(buffer.readVarInt() - 1);
  }

  function readOptionalConstant() {
    const index = buffer.readVarInt();
    if (index === 0) {
      return null;
    } else {
      return scanConstant(index - 1);
    }
  }
}

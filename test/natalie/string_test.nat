# encoding: UTF-8

require_relative '../spec_helper'

describe 'string' do
  it 'processes backslashes properly' do
    "foo\\bar".should == "foo" + "\\" + "bar"
  end

  describe '#inspect' do
    it 'returns a code representation of the string' do
      'foo'.inspect.should == '"foo"'
      "foo\nbar".inspect.should == "\"foo\\nbar\""
      "ğŸ˜‰ğŸ¤·".inspect.should == "\"ğŸ˜‰ğŸ¤·\""
    end
  end

  describe "#<=>" do
    it "should return -1 if lhs is less than rhs" do
      ('a' <=> 'b').should == -1
      ('a' <=> 'z').should == -1
    end

    it "should return 1 if lhs is greater than rhs" do
      ('b' <=> 'a').should == 1
      ('z' <=> 'a').should == 1
    end

    it "should return 0 if both sides are equal" do
      ('a' <=> 'a').should == 0
      ('z' <=> 'z').should == 0
    end
  end

  describe '#bytes' do
    it 'returns an array of byte values' do
      'foo'.bytes.should == [102, 111, 111]
    end
  end

  describe '#ord' do
    it 'returns the character code for the first character of the string' do
      ' '.ord.should == 32
      'a'.ord.should == 97
      'abc'.ord.should == 97
      'Äƒ'.ord.should == 259
      'â€'.ord.should == 8221
      'ğŸ˜‰'.ord.should == 128521
      'ğŸ˜‰ğŸ˜‰ğŸ˜‰'.ord.should == 128521
    end

    it 'raises an error if the string is empty' do
      -> { ''.ord }.should raise_error(ArgumentError, 'empty string')
    end
  end

  describe '#force_encoding' do
    it 'changes the encoding without reinterpreting the characters' do
      s = ''
      s.encoding.should == Encoding::UTF_8
      s.force_encoding 'ascii-8bit'
      s.encoding.should == Encoding::ASCII_8BIT
    end
  end

  describe '#chars' do
    it 'returns an array of characters' do
      'foo'.chars.should == ['f', 'o', 'o']
      s = "ğŸ˜‰â€Äƒa"
      s.chars.should == ["ğŸ˜‰", "â€", "Äƒ", "a"]
      s.force_encoding 'ascii-8bit'
      s.chars.map { |c| c.ord }.should == [240, 159, 152, 137, 226, 128, 157, 196, 131, 97]
    end
  end

  describe '[]' do
    it 'returns the character at the given index' do
      s = "ğŸ˜‰â€Äƒa"
      s[0].should == "ğŸ˜‰"
      s[1].should == "â€"
      s[2].should == "Äƒ"
      s[3].should == "a"
    end

    it 'returns nil if the index is past the end' do
      s = "ğŸ˜‰â€Äƒa"
      s[4].should == nil
    end

    it 'returns the character from the end given a negative index' do
      s = "ğŸ˜‰â€Äƒa"
      s[-1].should == "a"
      s[-2].should == "Äƒ"
      s[-3].should == "â€"
      s[-4].should == "ğŸ˜‰"
    end

    it 'returns nil if the negative index is too small' do
      s = "ğŸ˜‰â€Äƒa"
      s[-5].should == nil
    end
  end

  describe '#succ' do
    context 'given a single character' do
      it 'returns the next character' do
        'a'.succ.should == 'b'
        'm'.succ.should == 'n'
        'A'.succ.should == 'B'
        'M'.succ.should == 'N'
        '0'.succ.should == '1'
      end

      it 'loops on z' do
        'z'.succ.should == 'aa'
      end

      it 'loops on Z' do
        'Z'.succ.should == 'AA'
      end

      it 'loops on 9' do
        '9'.succ.should == '10'
      end
    end

    context 'given multiple characters' do
      it 'loops on z' do
        'az'.succ.should == 'ba'
        'aaz'.succ.should == 'aba'
        'zzz'.succ.should == 'aaaa'
      end
    end

    # TODO: handle mixed case, e.g. 'Az' and 'Zz'

    context 'given a character outside alphanumeric range' do
      it 'returns the next character' do
        'ğŸ‘'.succ.should == 'ğŸ‘'
      end
    end
  end
end
